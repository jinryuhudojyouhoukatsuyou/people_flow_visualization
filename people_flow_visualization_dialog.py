# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PeopleFlowVisualizationDialog
                                 A QGIS plugin
 This plugin visualize people flow
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2022-10-07
        git sha              : $Format:%H$
        copyright            : (C) 2022 by MLIT
        email                : trial@MILT
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import subprocess
import shutil
import csv
import processing
import datetime
import json
from urllib.parse import quote
import pandas as pd
import re
import numpy as np

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import pyqtSignal,QVariant,Qt
from qgis.PyQt.QtWidgets import QMessageBox,QFileDialog,QProgressDialog,QApplication

from qgis.core import *

from . import worldmesh
from chardet import detect
from datetime import timedelta

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'people_flow_visualization_dialog_base.ui'))


class PeopleFlowVisualizationDialog(QtWidgets.QDialog, FORM_CLASS):

    closingPlugin = pyqtSignal()

    def __init__(self,iface, parent=None):
        """Constructor."""
        super(PeopleFlowVisualizationDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.iface = iface
        
        self.default_file_path = os.path.expanduser('~') + '/Desktop'
        self.colName = {}
        self.header_count = 7
        self.mesh_index = 0
        self.add_poi = False
        self.meshcode_list = []
        self.setMinimumSize(1024, 700)
        self.setMaximumSize(1024, 700)
        self.filter = {}

        self.place_id_list = []
        self.file_002_sensor_path = None
        self.file_002_jinryu_path = None
        self.file_002_data_list = []    # 読み込んだCSVデータ(日時を最初のキー)
        self.file_002_point_name_list = {} # 計測点名Dict
        self.file_002_name = ""
        self.date_002_from = None
        self.date_002_to = None        

        self.area_id_list = []
        self.file_003_sensor_path = None
        self.file_003_name = ""

        self.tabWidget.setCurrentIndex(0)

        self.lnk_tebiki.clicked.connect(self.lnk_tebiki_clicked)
        self.lnk_riyo.clicked.connect(self.lnk_riyo_clicked)
        self.lnk_use.clicked.connect(self.lnk_use_clicked)
        self.lnk_guide.clicked.connect(self.lnk_guide_clicked)
        self.lnk_sample.clicked.connect(self.lnk_sample_clicked)


        self.btn_001.clicked.connect(self.move_001_1)
        self.btn_001_1_b.clicked.connect(self.move_0)
        self.btn_001_1_n.clicked.connect(self.move_001_2)
        self.btn_001_2_b.clicked.connect(self.move_001_1)
        self.btn_001_2_n.clicked.connect(self.move_001_3)      
        self.btn_001_3_b.clicked.connect(self.move_001_2)
        self.btn_001_3_n.clicked.connect(self.move_001_4)
        self.btn_001_4_b.clicked.connect(self.move_001_3)
        self.btn_001_4_n.clicked.connect(self.move_001_5)
        self.btn_001_5_b.clicked.connect(self.move_001_4)
        self.btn_001_5_n.clicked.connect(self.move_001_6)
        self.btn_001_6_b.clicked.connect(self.move_001_5)



        self.btn_002.clicked.connect(self.move_002_1)
        self.btn_002_1_b.clicked.connect(self.move_0)
        self.btn_002_1_n.clicked.connect(self.move_002_2)
        self.btn_002_2_b.clicked.connect(self.move_002_1)
        self.btn_002_2_n.clicked.connect(self.move_002_3)
        self.btn_002_3_b.clicked.connect(self.move_002_2)
        self.btn_002_3_n.clicked.connect(self.move_002_3_2)

        self.btn_002_3_b_2.clicked.connect(self.move_002_3)
        self.btn_002_3_n_2.clicked.connect(self.move_002_4)

        self.btn_002_4_b.clicked.connect(self.move_002_3_2)
        self.btn_002_4_n.clicked.connect(self.move_002_5)
        self.btn_002_5_b.clicked.connect(self.move_002_4)
        self.btn_002_5_n.clicked.connect(self.move_002_6)
        self.btn_002_6_b.clicked.connect(self.move_002_5)


        self.btn_003.clicked.connect(self.move_003_0)
        
        self.btn_003_001.clicked.connect(self.move_003_1)
        self.btn_003_002.clicked.connect(self.move_003_6)
        self.btn_003_0_b.clicked.connect(self.move_0)

        self.btn_003_1_b.clicked.connect(self.move_003_0)
        self.btn_003_1_n.clicked.connect(self.move_003_2)
        self.btn_003_2_b.clicked.connect(self.move_003_1)
        self.btn_003_2_n.clicked.connect(self.move_003_3)    
        self.btn_003_3_b.clicked.connect(self.move_003_2)
        self.btn_003_3_n.clicked.connect(self.move_003_3_2)

        self.btn_003_3_b_2.clicked.connect(self.move_003_3)
        self.btn_003_3_n_2.clicked.connect(self.move_003_4)
               
        self.btn_003_4_b.clicked.connect(self.move_003_3_2)
        self.btn_003_4_n.clicked.connect(self.move_003_5)
        self.btn_003_5_b.clicked.connect(self.move_003_4)

        self.btn_003_6_b.clicked.connect(self.move_003_0)
        self.btn_003_6_n.clicked.connect(self.move_003_7)
        self.btn_003_7_b.clicked.connect(self.move_003_6)
        self.btn_003_7_n.clicked.connect(self.move_003_7_2)     

        self.btn_003_7_b_2.clicked.connect(self.move_003_7)
        self.btn_003_7_n_2.clicked.connect(self.move_003_8)     

        self.btn_003_8_b.clicked.connect(self.move_003_7_2)
        self.btn_003_8_n.clicked.connect(self.move_003_9)
        self.btn_003_9_b.clicked.connect(self.move_003_8)

        self.btn_home_1.clicked.connect(self.move_0)
        self.btn_home_2.clicked.connect(self.move_0)
        self.btn_home_3.clicked.connect(self.move_0)
        self.btn_home_4.clicked.connect(self.move_0)
        self.btn_home_5.clicked.connect(self.move_0)
        self.btn_home_6.clicked.connect(self.move_0)

        self.btn_home_7.clicked.connect(self.move_0)
        self.btn_home_8.clicked.connect(self.move_0)
        self.btn_home_9.clicked.connect(self.move_0)
        self.btn_home_10.clicked.connect(self.move_0)
        self.btn_home_11.clicked.connect(self.move_0)
        self.btn_home_12.clicked.connect(self.move_0)

        self.btn_home_15.clicked.connect(self.move_0)
        self.btn_home_16.clicked.connect(self.move_0)
        self.btn_home_17.clicked.connect(self.move_0)
        self.btn_home_18.clicked.connect(self.move_0)
        self.btn_home_19.clicked.connect(self.move_0)

        self.btn_home_20.clicked.connect(self.move_0)
        self.btn_home_21.clicked.connect(self.move_0)
        self.btn_home_22.clicked.connect(self.move_0)
        #self.btn_home_23.clicked.connect(self.move_0)
        self.btn_home_24.clicked.connect(self.move_0)
        self.btn_home_25.clicked.connect(self.move_0)

        self.btn_home_9_2.clicked.connect(self.move_0)
        self.btn_home_17_2.clicked.connect(self.move_0)
        self.btn_home_22_2.clicked.connect(self.move_0)



        self.btn_meshcsv_load.clicked.connect(self.btn_meshcsv_load_clicked)
        self.btn_option_load.clicked.connect(self.btn_option_load_clicked)
        self.btn_poi_load.clicked.connect(self.btn_poi_load_clicked)
        self.btn_web_001.clicked.connect(self.web_001_clicked)
        self.btn_export_html_001.clicked.connect(self.export_html_001_clicked)
        self.btn_export_csv_001.clicked.connect(self.export_csv_001_clicked)
        self.btn_export_geojson_001.clicked.connect(self.export_geojson_001_clicked)

        self.btn_002_sensor_read.clicked.connect(self.sensor_read_002_clicked)
        self.btn_002_csv_read.clicked.connect(self.csv_read_002_clicked)
        self.btn_option_load_2.clicked.connect(self.btn_option_load_2_clicked)
        self.btn_web_002.clicked.connect(self.web_002_clicked)
        self.btn_export_html_002.clicked.connect(self.export_html_002_clicked)
        self.btn_export_csv_002.clicked.connect(self.export_csv_002_clicked)
        self.btn_export_geojson_002.clicked.connect(self.export_geojson_002_clicked)

        self.btn_003_sensor_read.clicked.connect(self.sensor_read_003_clicked)
        self.btn_003_csv_read.clicked.connect(self.csv_read_003_clicked)
        self.btn_option_load_3.clicked.connect(self.btn_option_load_3_clicked)

        self.btn_web_003.clicked.connect(self.web_003_clicked)
        self.btn_export_html_003.clicked.connect(self.export_html_003_clicked)
        self.btn_export_csv_003.clicked.connect(self.export_csv_003_clicked)
        self.btn_export_geojson_003.clicked.connect(self.export_geojson_003_clicked)
        #self.btn_export_geojson_003_2.clicked.connect(self.export_geojson_003_2_clicked)

        self.btn_001_2_n.setVisible(False)
        self.btn_001_5_n.setVisible(False)
        self.lbl_001_2_n.setVisible(False)
        self.lbl_001_5_n.setVisible(False)

        self.btn_002_2_n.setVisible(False)
        self.btn_002_3_n.setVisible(False)
        self.btn_002_5_n.setVisible(False)
        self.lbl_002_2_n.setVisible(False)
        self.lbl_002_3_n.setVisible(False)
        self.lbl_002_5_n.setVisible(False)

        self.lbl_003_2_n.setVisible(False)
        self.btn_003_2_n.setVisible(False)
        self.lbl_003_3_n.setVisible(False)
        self.btn_003_3_n.setVisible(False)
        self.lbl_003_4_n.setVisible(False)
        self.btn_003_4_n.setVisible(False)

        self.lbl_003_7_n.setVisible(False)
        self.btn_003_7_n.setVisible(False)
        self.lbl_003_8_n.setVisible(False)
        self.btn_003_8_n.setVisible(False)
        
        self.btn_003_sensor_read_2.clicked.connect(self.sensor_read_003_2_clicked)
        self.btn_option_load_4.clicked.connect(self.btn_option_load_4_clicked)
        self.btn_web_003_2.clicked.connect(self.web_003_2_clicked)
        self.btn_export_html_003_2.clicked.connect(self.export_html_003_2_clicked)
        self.btn_export_csv_003_2.clicked.connect(self.export_csv_003_2_clicked)
        self.btn_export_geojson_003_3.clicked.connect(self.export_geojson_003_3_clicked)

    def closeEvent(self, event):
        self.closingPlugin.emit()
        # レイヤ削除
        if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())
        if len(QgsProject.instance().mapLayersByName('sptial')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('sptial')[0].id())
        if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())
        if len(QgsProject.instance().mapLayersByName('poi')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('poi')[0].id())
        if len(QgsProject.instance().mapLayersByName('origin')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('origin')[0].id())
        if len(QgsProject.instance().mapLayersByName('destination')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('destination')[0].id())
        event.accept()

    def lnk_tebiki_clicked(self):
        url = os.path.dirname(__file__)+"/document/tebiki.pdf"       
        subprocess.Popen(['start', url], shell=True)      

    def lnk_riyo_clicked(self):
        url = os.path.dirname(__file__)+"/document/terms_of_use.pdf"       
        subprocess.Popen(['start', url], shell=True)        

    def lnk_use_clicked(self):
        url = os.path.dirname(__file__)+"/document/howtouse.pdf"       
        subprocess.Popen(['start', url], shell=True)        

    def lnk_guide_clicked(self):
        url = os.path.dirname(__file__)+"/document/guide.pdf"       
        subprocess.Popen(['start', url], shell=True)

    def lnk_sample_clicked(self):
        url = os.path.dirname(__file__)+"/document/samples.html"  
        subprocess.Popen(['start', url], shell=True)   

    def move_0(self):
        # レイヤ削除
        if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())
        if len(QgsProject.instance().mapLayersByName('sptial')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('sptial')[0].id())
        if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())
        if len(QgsProject.instance().mapLayersByName('poi')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('poi')[0].id())
        if len(QgsProject.instance().mapLayersByName('origin')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('origin')[0].id())
        if len(QgsProject.instance().mapLayersByName('destination')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('destination')[0].id())
        
        self.colName = {}
        self.list_meshcsv.clear()
        self.list_optioncsv.clear()
        self.list_poicsv.clear()
        self.lbl_003_filename.setText("")
        self.lbl_002_filename.setText("")
        self.lbl_003_filename_2.setText("")
        self.lbl_002_filename_2.setText("")

        self.list_optioncsv_2.clear()
        self.list_optioncsv_3.clear()
        self.list_optioncsv_4.clear()



        self.btn_001_2_n.setVisible(False)
        self.lbl_001_2_n.setVisible(False)
        self.btn_001_5_n.setVisible(False)
        self.lbl_001_5_n.setVisible(False)

        self.btn_002_2_n.setVisible(False)
        self.btn_002_3_n.setVisible(False)
        self.btn_002_5_n.setVisible(False)
        self.lbl_002_2_n.setVisible(False)
        self.lbl_002_3_n.setVisible(False)
        self.lbl_002_5_n.setVisible(False)

        self.lbl_003_2_n.setVisible(False)
        self.btn_003_2_n.setVisible(False)
        self.lbl_003_3_n.setVisible(False)
        self.btn_003_3_n.setVisible(False)
        self.lbl_003_4_n.setVisible(False)
        self.btn_003_4_n.setVisible(False)

        self.btn_003_7_n.setVisible(False)
        self.lbl_003_7_n.setVisible(False)

        self.lbl_001_2.setText("")
        self.lbl_001_3.setText("")
        self.lbl_001_4.setText("")
        self.lbl_001_5.setText("")
        self.lbl_002_sensor_msg.setText("")
        self.lbl_002_read_msg.setText("")
        self.lbl_001_6.setText("")
        self.lbl_002_sensor_msg_2.setText("")
        self.lbl_002_read_msg_2.setText("")
        self.lbl_001_9.setText("")


        self.lbl_001_8.setText("")
        self.lbl_001_11.setText("")
        self.lbl_001_12.setText("")

        self.lbl_003_filename_3.setText("")
        self.lbl_002_sensor_msg_3.setText("")

        self.lbl_option1.setText("option1")
        self.lbl_option2.setText("option2")
        self.lbl_option3.setText("option3")
        self.lbl_option4.setText("option4")
        self.lbl_option5.setText("option5")
        self.lbl_option6.setText("option6")
        self.lbl_option7.setText("option7")
        self.lbl_option8.setText("option8")
        self.lbl_option9.setText("option9")
        self.lbl_option10.setText("option10")

        self.lbl_option1_2.setText("option1")
        self.lbl_option2_2.setText("option2")
        self.lbl_option3_2.setText("option3")
        self.lbl_option4_2.setText("option4")
        self.lbl_option5_2.setText("option5")
        self.lbl_option6_2.setText("option6")
        self.lbl_option7_2.setText("option7")
        self.lbl_option8_2.setText("option8")
        self.lbl_option9_2.setText("option9")
        self.lbl_option10_2.setText("option10")

        self.lbl_option1_3.setText("option1")
        self.lbl_option2_3.setText("option2")
        self.lbl_option3_3.setText("option3")
        self.lbl_option4_3.setText("option4")
        self.lbl_option5_3.setText("option5")

        self.lbl_option1_4.setText("option1")
        self.lbl_option2_4.setText("option2")
        self.lbl_option3_4.setText("option3")
        self.lbl_option4_4.setText("option4")
        self.lbl_option5_4.setText("option5")

        self.tabWidget.setCurrentIndex(0)

    def move_001_1(self):
        self.tabWidget.setCurrentIndex(1)

    def move_001_2(self):
        self.tabWidget.setCurrentIndex(2)

    def move_001_3(self):
        self.tabWidget.setCurrentIndex(3)

    def move_001_4(self):
        self.tabWidget.setCurrentIndex(4)

    def move_001_5(self):
        if self.list_poicsv.count() == 0 :
            self.add_poi = False
        self.tabWidget.setCurrentIndex(5)

    def move_001_6(self):
        self.tabWidget.setCurrentIndex(6)  

    def move_002_1(self):
        self.tabWidget.setCurrentIndex(7)

    def move_002_2(self):
        self.tabWidget.setCurrentIndex(8)

    def move_002_3(self):
        self.tabWidget.setCurrentIndex(9)

    def move_002_3_2(self):
        self.tabWidget.setCurrentIndex(10)


    def move_002_4(self):
        self.tabWidget.setCurrentIndex(11)

        if self.date_002_from != None:
            self.cmb_002_dateTimeFrom.setDateTime(self.date_002_from)
        if self.date_002_to != None:
            self.cmb_002_dateTimeTo.setDateTime(self.date_002_to)

    # 期間指定
    def move_002_5(self):
        self.tabWidget.setCurrentIndex(12)
        ########################################
        # 期間日付取得
        __date_002_from = self.cmb_002_dateTimeFrom.dateTime().toString('yyyy/MM/dd hh:mm')
        __date_002_to = self.cmb_002_dateTimeTo.dateTime().toString('yyyy/MM/dd hh:mm')

        self.date_002_from = datetime.datetime.strptime(__date_002_from, '%Y/%m/%d %H:%M')
        self.date_002_to = datetime.datetime.strptime(__date_002_to, '%Y/%m/%d %H:%M')

        # 逆転していれば入れ替える
        if self.date_002_from > self.date_002_to:
            temp_from = self.date_002_to
            temp_to   = self.date_002_from
            self.date_002_to = temp_to
            self.date_002_from = temp_from

            self.cmb_002_dateTimeFrom.setDateTime(self.date_002_from)
            self.cmb_002_dateTimeTo.setDateTime(self.date_002_to)

    def move_002_6(self):
        self.tabWidget.setCurrentIndex(13)

    def move_003_0(self):
        self.tabWidget.setCurrentIndex(14)


    def move_003_1(self):
        self.tabWidget.setCurrentIndex(15)

    def move_003_2(self):
        self.tabWidget.setCurrentIndex(16)

    def move_003_3(self):
        self.tabWidget.setCurrentIndex(17)

    def move_003_3_2(self):
        self.tabWidget.setCurrentIndex(18)

    def move_003_4(self):
        self.tabWidget.setCurrentIndex(19)

    def move_003_5(self):
        self.tabWidget.setCurrentIndex(20)

    def move_003_6(self):
        self.tabWidget.setCurrentIndex(21)

    def move_003_7(self):
        self.tabWidget.setCurrentIndex(22)

    def move_003_7_2(self):
        self.tabWidget.setCurrentIndex(23)

    def move_003_8(self):
        self.tabWidget.setCurrentIndex(24)

    def move_003_9(self):
        self.tabWidget.setCurrentIndex(25)

   
    def btn_meshcsv_load_clicked(self):
        try :
            
            self.list_meshcsv.clear()
            self.lbl_001_2.setText('')

            if self.cmb_meshcode.currentIndex() == 0:
                QMessageBox.warning(None, "メッシュコード選択", "メッシュコードの種類を選択してください")
                return
                        
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:


                self.default_file_path = os.path.dirname(fname[0])
                progress = QProgressDialog('処理しています...', '', 0, 0, None)
                progress.setWindowModality(Qt.ApplicationModal)
                progress.setCancelButton(None)
                progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
                progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
                progress.show()

                QApplication.processEvents()

                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return                

                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                

                if len(header) < 2:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                self.header_count = len(header)
                if header[0] != "meshcode" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(meshcode)")
                    return

                if header[self.header_count-1] != "value" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(value)")
                    return

                for i in range(self.header_count-2):
                    if header[i+1] != "option" + str(i+1) :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                        return            
                
                if len(header) > 12:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return

                self.list_meshcsv.clear()

                if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
                    QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())

                csvLyr = QgsVectorLayer('None', 'csv', 'memory')
                csvLyrprov = csvLyr.dataProvider()   
                csvLyr.setProviderEncoding('UTF-8')
                csvLyr.dataProvider().setEncoding('UTF-8')   
                QgsProject.instance().addMapLayers([csvLyr])

                csvLyrprov.addAttributes([QgsField("meshcode", QVariant.String)])
                for i in range(self.header_count-2):
                    csvLyrprov.addAttributes([QgsField("option" + str(i+1), QVariant.String)])
                csvLyrprov.addAttributes([QgsField("value", QVariant.Double)])
                
                csvLyr.updateFields()

                featureList = []
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                    for row in csvreader:
                        float(row[self.header_count-1])
                        feat = QgsFeature()
                        feat.setAttributes(row)
                        featureList.append(feat)
                
                csvLyr.dataProvider().addFeatures(featureList)        
                csvLyr.commitChanges()


                meshcode = processing.run("qgis:listuniquevalues", {'INPUT':csvLyr,'FIELDS':['meshcode'],'OUTPUT':'TEMPORARY_OUTPUT'})
                meshcode_list = []
                for item in meshcode["OUTPUT"].getFeatures():
                    meshcode_list.append(str(item.attributes()[0]))

                if len(meshcode_list) == 0:
                    progress.close()
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return
                                
                # メッシュコード検証
                index = self.cmb_meshcode.currentIndex()
                for meshcode_list_1 in meshcode_list:
                    if isonlynum(meshcode_list_1) == False:
                        progress.close()
                        QMessageBox.warning(None, "CSVチェック", "メッシュコードに文字列が含まれています")
                        return

                    if index == 1 :
                        if len(meshcode_list_1) != 8 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return
                    if index == 2 :
                        if len(meshcode_list_1) != 9 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return
                    if index == 3 :
                        if len(meshcode_list_1) != 10 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return
                    if index == 4 :
                        if len(meshcode_list_1) != 11 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return
                    if index == 5 :
                        if len(meshcode_list_1) != 10 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return
                    if index == 6 :
                        if len(meshcode_list_1) != 11 :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "メッシュコードの桁数が一致しません")
                            return

                # フィルタ用データ設定
                layer1 = QgsProject.instance().mapLayersByName('csv')[0]

                option_list = []
                for cnt in range(self.header_count-2) :
                    option = processing.run("qgis:listuniquevalues", {'INPUT':layer1,'FIELDS':['option'+str(cnt+1)],'OUTPUT':'TEMPORARY_OUTPUT'})
                    option_list_temp = []
                    for item in option["OUTPUT"].getFeatures():
                        option_list_temp.append(item.attributes()[0])
                    option_list.append(option_list_temp)


                self.cmb_option1.setVisible(False)
                self.lbl_option1.setVisible(False)
                self.cmb_option2.setVisible(False)
                self.lbl_option2.setVisible(False)
                self.cmb_option3.setVisible(False)
                self.lbl_option3.setVisible(False)
                self.cmb_option4.setVisible(False)
                self.lbl_option4.setVisible(False)
                self.cmb_option5.setVisible(False)
                self.lbl_option5.setVisible(False)
                self.cmb_option6.setVisible(False)
                self.lbl_option6.setVisible(False)
                self.cmb_option7.setVisible(False)
                self.lbl_option7.setVisible(False)
                self.cmb_option8.setVisible(False)
                self.lbl_option8.setVisible(False)
                self.cmb_option9.setVisible(False)
                self.lbl_option9.setVisible(False)
                self.cmb_option10.setVisible(False)
                self.lbl_option10.setVisible(False)

                self.len = len(option_list)

                if self.len >= 1 : 
                    self.cmb_option1.clear()
                    self.cmb_option1.addItem('ALL')
                    self.cmb_option1.addItems(option_list[0])
                    self.cmb_option1.model().sort(0)
                    self.cmb_option1.setVisible(True)
                    self.lbl_option1.setVisible(True)
                if self.len >= 2 : 
                    self.cmb_option2.clear()
                    self.cmb_option2.addItem('ALL')
                    self.cmb_option2.addItems(option_list[1])
                    self.cmb_option2.model().sort(0)
                    self.cmb_option2.setVisible(True)
                    self.lbl_option2.setVisible(True)
                if self.len >= 3 : 
                    self.cmb_option3.clear()
                    self.cmb_option3.addItem('ALL')
                    self.cmb_option3.addItems(option_list[2])
                    self.cmb_option3.model().sort(0)
                    self.cmb_option3.setVisible(True)
                    self.lbl_option3.setVisible(True)
                if self.len >= 4 : 
                    self.cmb_option4.clear()
                    self.cmb_option4.addItem('ALL')
                    self.cmb_option4.addItems(option_list[3])
                    self.cmb_option4.model().sort(0)
                    self.cmb_option4.setVisible(True)
                    self.lbl_option4.setVisible(True)
                if self.len >= 5 : 
                    self.cmb_option5.clear()
                    self.cmb_option5.addItem('ALL')
                    self.cmb_option5.addItems(option_list[4])
                    self.cmb_option5.model().sort(0)
                    self.cmb_option5.setVisible(True)
                    self.lbl_option5.setVisible(True)
                if self.len >= 6 : 
                    self.cmb_option6.clear()
                    self.cmb_option6.addItem('ALL')
                    self.cmb_option6.addItems(option_list[5])
                    self.cmb_option6.model().sort(0)
                    self.cmb_option6.setVisible(True)
                    self.lbl_option6.setVisible(True)
                if self.len >= 7 : 
                    self.cmb_option7.clear()
                    self.cmb_option7.addItem('ALL')
                    self.cmb_option7.addItems(option_list[6])
                    self.cmb_option7.model().sort(0)
                    self.cmb_option7.setVisible(True)
                    self.lbl_option7.setVisible(True)
                if self.len >= 8 : 
                    self.cmb_option8.clear()
                    self.cmb_option8.addItem('ALL')
                    self.cmb_option8.addItems(option_list[7])
                    self.cmb_option8.model().sort(0)
                    self.cmb_option8.setVisible(True)
                    self.lbl_option8.setVisible(True)
                if self.len >= 9 : 
                    self.cmb_option9.clear()
                    self.cmb_option9.addItem('ALL')
                    self.cmb_option9.addItems(option_list[8])
                    self.cmb_option9.model().sort(0)
                    self.cmb_option9.setVisible(True)
                    self.lbl_option9.setVisible(True)
                if self.len >= 10 : 
                    self.cmb_option10.clear()
                    self.cmb_option10.addItem('ALL')
                    self.cmb_option10.addItems(option_list[9])
                    self.cmb_option10.model().sort(0)
                    self.cmb_option10.setVisible(True)
                    self.lbl_option10.setVisible(True)

                self.mesh_index = index
                self.meshcode_list = meshcode_list

                self.btn_001_2_n.setVisible(True)
                self.lbl_001_2_n.setVisible(True)

                self.list_meshcsv.addItem(os.path.basename(fname[0]))

                self.lbl_001_2.setText('人流データの読み込みに成功しました。')
                QApplication.processEvents()
                progress.close()

            else :
                self.list_meshcsv.clear()
                self.lbl_001_2.setText('')
                self.btn_001_2_n.setVisible(False)
                self.lbl_001_2_n.setVisible(False)
        except ValueError as e:
            progress.close()
            QMessageBox.warning(None, "CSVチェック", "フィールド(value)の値を数値として保存できませんでした")
        except :
            progress.close()
            QMessageBox.warning(None, "人流データ読み込み", "ファイル読み込み時に問題が発生しました")

    def btn_option_load_clicked(self):
        try:
            self.lbl_001_3.setText('')
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:
                self.default_file_path = os.path.dirname(fname[0])
                self.list_optioncsv.clear()

                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :

                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                

                if len(header) != 2:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                if header[0] != "option" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                    return

                if header[1] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return


                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l_0 = [rows[0] for rows in reader]

                if len(l_0) != len(set(l_0)) :
                    QMessageBox.warning(None, "CSVチェック", "optionが重複しています")
                    return  
                
                for lv in l_0 :
                    if not(lv in ['option','option1','option2','option3','option4','option5','option6','option7','option8','option9','option10']) :
                        QMessageBox.warning(None, "CSVチェック", "option1-10以外の項目が設定されています")
                        return 
                
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l = {rows[0]:rows[1] for rows in reader}

                self.colName = l

                self.lbl_option1.setText(self.colName.get('option1', 'option1'))
                self.lbl_option2.setText(self.colName.get('option2', 'option2'))
                self.lbl_option3.setText(self.colName.get('option3', 'option3'))
                self.lbl_option4.setText(self.colName.get('option4', 'option4'))
                self.lbl_option5.setText(self.colName.get('option5', 'option5'))
                self.lbl_option6.setText(self.colName.get('option6', 'option6'))
                self.lbl_option7.setText(self.colName.get('option7', 'option7'))
                self.lbl_option8.setText(self.colName.get('option8', 'option8'))
                self.lbl_option9.setText(self.colName.get('option9', 'option9'))
                self.lbl_option10.setText(self.colName.get('option10', 'option10'))

                self.list_optioncsv.addItem(os.path.basename(fname[0]))
                self.lbl_001_3.setText('オプション情報の読み込みに成功しました。')

            else :
                self.list_optioncsv.clear()
                self.lbl_001_3.setText('')
                self.colName = {}
        except:
            QMessageBox.warning(None, "オプション情報読み込み", "ファイル読み込み時に問題が発生しました")

    def btn_poi_load_clicked(self):
        try:
            self.lbl_001_4.setText('')
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:
                self.default_file_path = os.path.dirname(fname[0])
                self.list_poicsv.clear()
                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   

                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)

                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return  

                if len(header) != 3:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return

                if header[0] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return
                if header[1] != "lat" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lat)")
                    return
                if header[2] != "lon" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lon)")
                    return
                
                if file_encoding == "cp932":
                    file_encoding = 'Shift_JIS'
                if file_encoding == "utf-8-sig":
                    file_encoding = 'utf-8'

                uri = 'file:///'+quote(fname[0])+'?delimiter={}&crs=epsg:4326&encoding={}&xField={}&yField={}'.format(',',file_encoding ,'lon', 'lat')

                if len(QgsProject.instance().mapLayersByName('poi')) >= 1 :
                    QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('poi')[0].id())
                #読み込み
                layer = QgsVectorLayer(uri, 'poi', 'delimitedtext') 


                #レイヤに追加
                QgsProject.instance().addMapLayer(layer)

                self.list_poicsv.addItem(os.path.basename(fname[0]))

                QgsVectorFileWriter.writeAsVectorFormat(
                    layer,
                    os.path.dirname(__file__) + '/temp/poi.geojson',
                    'UTF-8',
                    QgsCoordinateReferenceSystem("EPSG:4326"),
                    'GeoJSON'
                )
                self.add_poi = True
                self.lbl_001_4.setText('地点名称データの読み込みに成功しました。')

            else :
                self.add_poi = False
                self.list_poicsv.clear()
        except:
            QMessageBox.warning(None, "地点名称読み込み", "ファイル読み込み時に問題が発生しました")

    def web_001_clicked(self):
        try:
            self.lbl_001_5.setText('')
            progress = QProgressDialog('処理しています...', '', 0, 0, None)
            progress.setWindowModality(Qt.ApplicationModal)
            progress.setCancelButton(None)
            progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
            progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
            progress.show()

            QApplication.processEvents()

            self.btn_001_5_n.setVisible(False)
            self.lbl_001_5_n.setVisible(False)

            layer1 = QgsProject.instance().mapLayersByName('csv')[0]

            QApplication.processEvents()

            filter_list = []
            if self.len >= 1 : filter_list.append(str(self.cmb_option1.currentText()))
            if self.len >= 2 : filter_list.append(str(self.cmb_option2.currentText()))
            if self.len >= 3 : filter_list.append(str(self.cmb_option3.currentText()))
            if self.len >= 4 : filter_list.append(str(self.cmb_option4.currentText()))
            if self.len >= 5 : filter_list.append(str(self.cmb_option5.currentText()))
            if self.len >= 6 : filter_list.append(str(self.cmb_option6.currentText()))
            if self.len >= 7 : filter_list.append(str(self.cmb_option7.currentText()))
            if self.len >= 8 : filter_list.append(str(self.cmb_option8.currentText()))
            if self.len >= 9 : filter_list.append(str(self.cmb_option9.currentText()))
            if self.len >= 10 : filter_list.append(str(self.cmb_option10.currentText()))

            sfilter = ""
            layer1.setSubsetString(sfilter)
            self.filter = {}
            alist = []
            for cnt in range(self.header_count-2) :
                if cnt == 0:
                    if filter_list[0] == 'ALL' :
                        alist.append("option1")
                    else :
                        sfilter += "\"option1\" = '%s'" % (filter_list[0])
                    self.filter["option1"] = [self.colName.get('option1', 'option1'),filter_list[0]]
                else:
                    if filter_list[cnt] == 'ALL' :
                        alist.append("option" + str(cnt+1))
                    else :
                        if sfilter == "" :
                            sfilter +=  "\"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                        else:
                            sfilter +=  " AND \"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                    self.filter["option" + str(cnt+1)] = [self.colName.get("option" + str(cnt+1), "option" + str(cnt+1)),filter_list[cnt]]


            layer1.setSubsetString(sfilter)
            if layer1.featureCount() <= 0 :
                    progress.close()
                    QMessageBox.warning(None, "分析処理", "該当レコードがありません")
                    return
                        
            QApplication.processEvents()
            meshcode = processing.run("qgis:listuniquevalues", {'INPUT':layer1,'FIELDS':['meshcode'],'OUTPUT':'TEMPORARY_OUTPUT'})
            meshcode_list = []
            for item in meshcode["OUTPUT"].getFeatures():
                meshcode_list.append(str(item.attributes()[0]))

            self.create_mesh(meshcode_list,self.mesh_index)

            QApplication.processEvents()

            if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
                QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())

            os.remove(os.path.dirname(__file__) + '/temp/result.gpkg')

            self.datajoin(alist)

            layer1 = self.iface.addVectorLayer(os.path.dirname(__file__) + '/temp/result.gpkg','result','ogr')
            # スタイル指定
            renderer = QgsGraduatedSymbolRenderer() 
            renderer.setClassAttribute('value') 
            layer1.setRenderer(renderer)
            if layer1.featureCount() < 10 :
                layer1.renderer().updateClasses(layer1, QgsGraduatedSymbolRenderer.EqualInterval, 9)
            else:
                layer1.renderer().updateClasses(layer1, QgsGraduatedSymbolRenderer.Jenks, 9)
            default_style = QgsStyle().defaultStyle()
            color_ramp = default_style.colorRamp('Reds')
            layer1.renderer().updateColorRamp(color_ramp)
            self.iface.layerTreeView().refreshLayerSymbology(layer1.id())
            self.iface.mapCanvas().refreshAllLayers()

            self.fill_color_attribute_graduatedsymbol_renderer(layer1,"fill")

            QgsVectorFileWriter.writeAsVectorFormat(
                layer1,
                os.path.dirname(__file__) + '/temp/result.geojson',
                'UTF-8',
                QgsCoordinateReferenceSystem("EPSG:4326"),
                'GeoJSON',
                layerOptions=['id_field=fid']
            )
            
            url = os.path.dirname(__file__)+"/html/001.html"
            self.replaceData(url,os.path.dirname(__file__) + '/temp/result.geojson',None, False,True)

            if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
                QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())
            
            progress.close()
            
            QMessageBox.information(None, "分析処理", "分析処理が完了しました。")
            self.move_001_6()
            self.btn_001_5_n.setVisible(True)
            self.lbl_001_5_n.setVisible(True)

        except:
            progress.close()
            QMessageBox.warning(None, "分析処理", "分析処理時に問題が発生しました")

    def export_html_001_clicked(self):
        # ダイアログ表示
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                    os.path.expanduser('~') + '/Desktop','HTML file(*.html)')
        url = os.path.dirname(__file__)+"/html/001.html"

        try: 
            if output_path[0] :
                shutil.copyfile(url+".html", output_path[0])
                url = output_path[0]

                subprocess.Popen(['start', url], shell=True)
        except:
            QMessageBox.warning(None, "HTML保存", "HTML保存時に問題が発生しました")        

    def export_csv_001_clicked(self):
        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','CSV(*.csv)')
        try :
            if output_path[0] :                                   
                shutil.copyfile(os.path.dirname(__file__) + '/temp/result.csv', output_path[0])
        except:
            QMessageBox.warning(None, "CSV保存", "CSV保存時に問題が発生しました")        

    def export_geojson_001_clicked(self):
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','GeoJson(*.geojson)')
        try :
            if output_path[0] :
                shutil.copyfile(os.path.dirname(__file__) + '/temp/result.geojson', output_path[0])
        except:
            QMessageBox.warning(None, "geojson保存", "geojson保存時に問題が発生しました")        


    def sensor_read_002_clicked(self):
        try :
            # センサー情報の読み込み
            (fileName, selectedFilter) = QFileDialog.getOpenFileName(self, 'センサー情報', 
                                self.default_file_path, "センサー情報csv (*.csv)")

            # self.file_002_sensor_reader = None
            if fileName != None and fileName != "":
                self.default_file_path = os.path.dirname(fileName)
                
                file_encoding = encodingCheck(fileName)
                if "error" in file_encoding :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)

                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return        
                if len(header) < 4:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if header[0] != "place_id" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(place_id)")
                    return
                if header[1] != "lat" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lat)")
                    return
                if header[2] != "lon" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lon)")
                    return                
                if header[3] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return
                if len(header) > 4:
                    if header[4] != "option1" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option1)")
                        return
                if len(header) > 5:
                    if header[5] != "option2" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option2)")
                        return
                if len(header) > 6:
                    if header[6] != "option3" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option3)")
                        return
                if len(header) > 7:
                    if header[7] != "option4" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option4)")
                        return
                if len(header) > 8:
                    if header[8] != "option5" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option5)")
                        return

                if len(header) > 9:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                if sum([1 for _ in open(fileName, encoding=file_encoding, newline='')]) == 1:
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return
                place_id_list = []
                with open(fileName,encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    i = 0
                    for row in reader:
                        if i == 0:
                            i=i+1
                            continue
                        if row[0] == "" :
                            QMessageBox.warning(None, "CSVチェック", "place_idが指定されていません")
                            return
                        if row[1] == "" :
                            QMessageBox.warning(None, "CSVチェック", "latが指定されていません")
                            return
                        if row[2] == "" :
                            QMessageBox.warning(None, "CSVチェック", "lonが指定されていません")
                            return
                        if row[3] == "" :
                            QMessageBox.warning(None, "CSVチェック", "nameが指定されていません")
                            return
                        place_id_list.append(row[0])
                        # 座標値チェック
                        float(row[1])
                        float(row[2])
                        if (float(row[1]) <= -90) or (float(row[1]) >= 90) :
                            float(row[1] + 'a')
                        if (float(row[2]) <= -180) or (float(row[2]) >= 180) :
                            float(row[2] + 'a')                        
                        i=i+1

                if len(place_id_list) != len(set(place_id_list)) :
                    QMessageBox.warning(None, "CSVチェック", "place_idが重複しています")
                    return
                self.place_id_list = place_id_list
                file_path = fileName
                file_name = file_path[file_path.rfind("/") + 1:]
                self.lbl_003_filename.setText(file_name)

                self.file_002_sensor_path = fileName


                self.lbl_002_sensor_msg.setText("センサー情報の読み込みに成功しました。")
                self.btn_002_2_n.setVisible(True)
                self.lbl_002_2_n.setVisible(True)
        except ValueError as e:
            QMessageBox.warning(None, "CSVチェック", "センサー情報の座標が登録できません")
        except:
            QMessageBox.warning(None, "センサー情報読み込み", "ファイル読み込み時に問題が発生しました")      

    def csv_read_002_clicked(self):
        try:

            (fileName, selectedFilter) = QFileDialog.getOpenFileName(self, '計測データ選択', 
                                self.default_file_path, "計測データcsv (*.csv)")

            if fileName != None and fileName != "":
                self.default_file_path = os.path.dirname(fileName)
                progress = QProgressDialog('処理しています...', '', 0, 0, None)
                progress.setWindowModality(Qt.ApplicationModal)
                progress.setCancelButton(None)
                progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
                progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
                progress.show()

                QApplication.processEvents()
                file_encoding = encodingCheck(fileName)
                if "error" in file_encoding :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return
                #ヘッダー確認
                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                
                if len(header) < 7:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if len(header) > 18:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                self.header_count = len(header)
                if header[0] != "place_id" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(place_id)")
                    return
                if header[1] != "year" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(year)")
                    return
                if header[2] != "month" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(month)")
                    return
                if header[3] != "day" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(day)")
                    return
                if header[4] != "hour" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(hour)")
                    return
                if header[5] != "minute" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(minute)")
                    return
                if header[self.header_count-1] != "value" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(value)")
                    return

                for i in range(0,self.header_count-7):
                    if header[i+6] != "option" + str(i+1) :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                        return            

                if sum([1 for _ in open(fileName, encoding=file_encoding, newline='')]) == 1:
                    progress.close()
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return
                
                file_path = fileName
                file_name = file_path[file_path.rfind("/") + 1:]
                self.lbl_002_filename.setText(file_name)
                self.file_002_jinryu_path = fileName

                # ファイル読み込み
                with open(file_path, encoding=file_encoding, newline='') as f:

                    reader = csv.reader(f)
                    i=0
                    for row in reader:
                        # ヘッダーがある前提でスキップ
                        if i == 0:
                            i=i+1
                            continue

                        if row[0] == "":
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "place_idが指定されていません")
                            return 

                        if not(row[0] in self.place_id_list) :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "place_idがセンサーと一致しません")
                            return 

                        # 日付を取得（カラムごとにきちんと区切っておく）
                        row_date_str = row[1] + "/" + row[2] + "/" + row[3] + " " + row[4] + ":" + row[5]
                        try:
                            row_date = datetime.datetime.strptime(row_date_str, '%Y/%m/%d %H:%M')
                        except Exception as e:
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "無効な日付、または日付以外が入力されています")
                            return 

                        # 日時, 計測点id, 数値(人数)
                        r_data = [row_date, row[0], row[len(row)-1]]
                        self.file_002_data_list.append(r_data)


                        # 期間のための日時取得
                        if i==1:
                            self.date_002_from = row_date
                            self.date_002_to = row_date
                        else:
                            if row_date < self.date_002_from:
                                self.date_002_from = row_date
                            if row_date > self.date_002_to:
                                self.date_002_to = row_date
                        i=i+1

                # センサーCSV読み込み
                if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
                    QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())

                csvLyr = QgsVectorLayer('None', 'csv', 'memory')
                csvLyrprov = csvLyr.dataProvider()   
                csvLyr.setProviderEncoding('UTF-8')
                csvLyr.dataProvider().setEncoding('UTF-8')   
                QgsProject.instance().addMapLayers([csvLyr])

                csvLyrprov.addAttributes([QgsField("place_id", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("year", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("month", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("day", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("hour", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("minute", QVariant.String)])
                for i in range(0,self.header_count-7):
                    csvLyrprov.addAttributes([QgsField("option" + str(i+1), QVariant.String)])
                csvLyrprov.addAttributes([QgsField("value", QVariant.Double)])
                    
                csvLyr.updateFields()
                file_encoding = encodingCheck(self.file_002_jinryu_path)

                featureList = []
                with open(self.file_002_jinryu_path, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                    for row in csvreader:
                        float(row[self.header_count-1])
                        feat = QgsFeature()
                        feat.setAttributes(row)
                        featureList.append(feat)
                    
                csvLyr.dataProvider().addFeatures(featureList)        
                csvLyr.commitChanges()
                
                layer1 = csvLyr


                option_list = []
                for cnt in range(0,self.header_count-7) :
                    option = processing.run("qgis:listuniquevalues", {'INPUT':layer1,'FIELDS':['option'+str(cnt+1)],'OUTPUT':'TEMPORARY_OUTPUT'})
                    option_list_temp = []
                    for item in option["OUTPUT"].getFeatures():
                        option_list_temp.append(item.attributes()[0])
                    option_list.append(option_list_temp)


                self.cmb_option1_2.setVisible(False)
                self.lbl_option1_2.setVisible(False)
                self.cmb_option2_2.setVisible(False)
                self.lbl_option2_2.setVisible(False)
                self.cmb_option3_2.setVisible(False)
                self.lbl_option3_2.setVisible(False)
                self.cmb_option4_2.setVisible(False)
                self.lbl_option4_2.setVisible(False)
                self.cmb_option5_2.setVisible(False)
                self.lbl_option5_2.setVisible(False)
                self.cmb_option6_2.setVisible(False)
                self.lbl_option6_2.setVisible(False)
                self.cmb_option7_2.setVisible(False)
                self.lbl_option7_2.setVisible(False)
                self.cmb_option8_2.setVisible(False)
                self.lbl_option8_2.setVisible(False)
                self.cmb_option9_2.setVisible(False)
                self.lbl_option9_2.setVisible(False)
                self.cmb_option10_2.setVisible(False)
                self.lbl_option10_2.setVisible(False)

                self.len = len(option_list)

                if self.len >= 1 : 
                    self.cmb_option1_2.clear()
                    self.cmb_option1_2.addItem('ALL')
                    self.cmb_option1_2.addItems(option_list[0])
                    self.cmb_option1_2.model().sort(0)
                    self.cmb_option1_2.setVisible(True)
                    self.lbl_option1_2.setVisible(True)
                if self.len >= 2 : 
                    self.cmb_option2_2.clear()
                    self.cmb_option2_2.addItem('ALL')
                    self.cmb_option2_2.addItems(option_list[1])
                    self.cmb_option2_2.model().sort(0)
                    self.cmb_option2_2.setVisible(True)
                    self.lbl_option2_2.setVisible(True)
                if self.len >= 3 : 
                    self.cmb_option3_2.clear()
                    self.cmb_option3_2.addItem('ALL')
                    self.cmb_option3_2.addItems(option_list[2])
                    self.cmb_option3_2.model().sort(0)
                    self.cmb_option3_2.setVisible(True)
                    self.lbl_option3_2.setVisible(True)
                if self.len >= 4 : 
                    self.cmb_option4_2.clear()
                    self.cmb_option4_2.addItem('ALL')
                    self.cmb_option4_2.addItems(option_list[3])
                    self.cmb_option4_2.model().sort(0)
                    self.cmb_option4_2.setVisible(True)
                    self.lbl_option4_2.setVisible(True)
                if self.len >= 5 : 
                    self.cmb_option5_2.clear()
                    self.cmb_option5_2.addItem('ALL')
                    self.cmb_option5_2.addItems(option_list[4])
                    self.cmb_option5_2.model().sort(0)
                    self.cmb_option5_2.setVisible(True)
                    self.lbl_option5_2.setVisible(True)
                if self.len >= 6 : 
                    self.cmb_option6_2.clear()
                    self.cmb_option6_2.addItem('ALL')
                    self.cmb_option6_2.addItems(option_list[5])
                    self.cmb_option6_2.model().sort(0)
                    self.cmb_option6_2.setVisible(True)
                    self.lbl_option6_2.setVisible(True)
                if self.len >= 7 : 
                    self.cmb_option7_2.clear()
                    self.cmb_option7_2.addItem('ALL')
                    self.cmb_option7_2.addItems(option_list[6])
                    self.cmb_option7_2.model().sort(0)
                    self.cmb_option7_2.setVisible(True)
                    self.lbl_option7_2.setVisible(True)
                if self.len >= 8 : 
                    self.cmb_option8_2.clear()
                    self.cmb_option8_2.addItem('ALL')
                    self.cmb_option8_2.addItems(option_list[7])
                    self.cmb_option8_2.model().sort(0)
                    self.cmb_option8_2.setVisible(True)
                    self.lbl_option8_2.setVisible(True)
                if self.len >= 9 : 
                    self.cmb_option9_2.clear()
                    self.cmb_option9_2.addItem('ALL')
                    self.cmb_option9_2.addItems(option_list[8])
                    self.cmb_option9_2.model().sort(0)
                    self.cmb_option9_2.setVisible(True)
                    self.lbl_option9_2.setVisible(True)
                if self.len >= 10 : 
                    self.cmb_option10_2.clear()
                    self.cmb_option10_2.addItem('ALL')
                    self.cmb_option10_2.addItems(option_list[9])
                    self.cmb_option10_2.model().sort(0)
                    self.cmb_option10_2.setVisible(True)
                    self.lbl_option10_2.setVisible(True)
                
                progress.close()
                self.lbl_002_read_msg.setText("計測データの読み込みに成功しました。")

                self.file_002_name = file_name

                self.btn_002_3_n.setVisible(True)
                self.lbl_002_3_n.setVisible(True)

        except ValueError as e:
            progress.close()
            QMessageBox.warning(None, "CSVチェック", "フィールド(value)の値を数値として保存できませんでした")
        except :
            progress.close()
            QMessageBox.warning(None, "人流データ読み込み", "ファイル読み込み時に問題が発生しました")

    def btn_option_load_2_clicked(self):
        try:
            self.lbl_001_8.setText('')
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:
                self.default_file_path = os.path.dirname(fname[0])
                self.list_optioncsv_2.clear()

                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :

                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                

                if len(header) != 2:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                if header[0] != "option" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                    return

                if header[1] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return


                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l_0 = [rows[0] for rows in reader]

                if len(l_0) != len(set(l_0)) :
                    QMessageBox.warning(None, "CSVチェック", "optionが重複しています")
                    return  
                
                for lv in l_0 :
                    if not(lv in ['option','option1','option2','option3','option4','option5','option6','option7','option8','option9','option10']) :
                        QMessageBox.warning(None, "CSVチェック", "option1-10以外の項目が設定されています")
                        return 
                
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l = {rows[0]:rows[1] for rows in reader}

                self.colName = l

                self.lbl_option1_2.setText(self.colName.get('option1', 'option1'))
                self.lbl_option2_2.setText(self.colName.get('option2', 'option2'))
                self.lbl_option3_2.setText(self.colName.get('option3', 'option3'))
                self.lbl_option4_2.setText(self.colName.get('option4', 'option4'))
                self.lbl_option5_2.setText(self.colName.get('option5', 'option5'))
                self.lbl_option6_2.setText(self.colName.get('option6', 'option6'))
                self.lbl_option7_2.setText(self.colName.get('option7', 'option7'))
                self.lbl_option8_2.setText(self.colName.get('option8', 'option8'))
                self.lbl_option9_2.setText(self.colName.get('option9', 'option9'))
                self.lbl_option10_2.setText(self.colName.get('option10', 'option10'))

                self.list_optioncsv_2.addItem(os.path.basename(fname[0]))
                self.lbl_001_8.setText('オプション情報の読み込みに成功しました。')

            else :
                self.list_optioncsv_2.clear()
                self.lbl_001_8.setText('')
                self.colName = {}
        except:
            QMessageBox.warning(None, "オプション情報読み込み", "ファイル読み込み時に問題が発生しました")




    def web_002_clicked(self):
        try:
            self.lbl_001_6.setText('')
            self.btn_002_5_n.setVisible(False)
            self.lbl_002_5_n.setVisible(False)
            
            progress = QProgressDialog('処理しています...', '', 0, 0, None)
            progress.setWindowModality(Qt.ApplicationModal)
            progress.setCancelButton(None)
            progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
            progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
            progress.show()

            QApplication.processEvents()
            
            self.btn_002_5_n.setVisible(False)
            self.lbl_002_5_n.setVisible(False)
            layer1 = QgsProject.instance().mapLayersByName('csv')[0]
            filter_list = []
            if self.len >= 1 : filter_list.append(str(self.cmb_option1_2.currentText()))
            if self.len >= 2 : filter_list.append(str(self.cmb_option2_2.currentText()))
            if self.len >= 3 : filter_list.append(str(self.cmb_option3_2.currentText()))
            if self.len >= 4 : filter_list.append(str(self.cmb_option4_2.currentText()))
            if self.len >= 5 : filter_list.append(str(self.cmb_option5_2.currentText()))
            if self.len >= 6 : filter_list.append(str(self.cmb_option6_2.currentText()))
            if self.len >= 7 : filter_list.append(str(self.cmb_option7_2.currentText()))
            if self.len >= 8 : filter_list.append(str(self.cmb_option8_2.currentText()))
            if self.len >= 9 : filter_list.append(str(self.cmb_option9_2.currentText()))
            if self.len >= 10 : filter_list.append(str(self.cmb_option10_2.currentText()))

            sfilter = ""
            self.filter = {}

            alist = []
            for cnt in range(self.header_count-7) :
                if cnt == 0:
                    if filter_list[0] == 'ALL' :
                        alist.append("option1")
                    else :
                        sfilter += "\"option1\" = '%s'" % (filter_list[0])
                    self.filter["option1"] = [self.colName.get('option1', 'option1'),filter_list[0]]
                else:
                    if filter_list[cnt] == 'ALL' :
                        alist.append("option" + str(cnt+1))
                    else :
                        if sfilter == "" :
                            sfilter +=  "\"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                        else :    
                            sfilter +=  " AND \"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                    self.filter["option" + str(cnt+1)] = [self.colName.get("option" + str(cnt+1), "option" + str(cnt+1)),filter_list[cnt]]

            layer1.setSubsetString(sfilter)

            QApplication.processEvents()

            if layer1.featureCount() <= 0:
                progress.close()
                QMessageBox.warning(None, "分析処理", "該当レコードがありません")
                return  
            #self.lbl_002_07_msg_status.setText("分析実行中")
            idx1 = layer1.dataProvider().fields().indexFromName("place_id")
            idx2 = layer1.dataProvider().fields().indexFromName("year")
            idx3 = layer1.dataProvider().fields().indexFromName("month")
            idx4 = layer1.dataProvider().fields().indexFromName("day")
            idx5 = layer1.dataProvider().fields().indexFromName("hour")
            idx6 = layer1.dataProvider().fields().indexFromName("minute")
            idx7 = layer1.dataProvider().fields().indexFromName("value")

            # 日時, 計測点id, 数値(人数)
            self.file_002_data_list = []
            for feat in layer1.getFeatures():
                attribute_map = feat.attributes()
                value = attribute_map[idx7]
                # 日付を取得（カラムごとにきちんと区切っておく）
                row_date_str = attribute_map[idx2] + "/" + attribute_map[idx3] + "/" + attribute_map[idx4] + " " + attribute_map[idx5] + ":" + attribute_map[idx6]
                row_date = datetime.datetime.strptime(row_date_str, '%Y/%m/%d %H:%M')

                r_data = [row_date, attribute_map[idx1], attribute_map[idx7]]
                self.file_002_data_list.append(r_data)

            self.datafilter()
            ########################################
            # 地図用のGeoJson作成

            ###############################################################
            # 1.仮レイヤ作成
            if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
                QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())

            new_layer = QgsVectorLayer("point", "result", "memory")

            QgsProject.instance().addMapLayer(new_layer)
            prov = new_layer.dataProvider()
            caps = prov.capabilities()
            if caps & QgsVectorDataProvider.AddAttributes:
                prov.addAttributes(
                    [
                        QgsField('id', QVariant.String),
                        QgsField('value', QVariant.Int),
                        QgsField('name', QVariant.String),
                        QgsField('option1', QVariant.String),
                        QgsField('option2', QVariant.String),
                        QgsField('option3', QVariant.String),
                        QgsField('option4', QVariant.String),
                        QgsField('option5', QVariant.String)
                        # QgsField('value', QVariant.Double, len=10,prec=2)
                    ])
                new_layer.updateFields()

            # 2.CSVから位置情報取得およびレイヤに追加
            # 人数の最大、最小
            circle_max = None
            circle_min = None

            new_layer.startEditing()
            # for feat in _layer.getFeatures():
            file_encoding = encodingCheck(self.file_002_sensor_path)
            with open(self.file_002_sensor_path, encoding=file_encoding, newline='') as f:
                reader = csv.reader(f)
                i=0
                for f_row in reader:
                    # ヘッダーがある前提でスキップ
                    if i == 0:
                        i=i+1
                        continue

                    if f_row[0] not in self.file_002_point_name_list:
                        self.file_002_point_name_list[f_row[0]] = f_row[3]


                    sensor_id = f_row[0]
                    if sensor_id in self.point_geo_features: # file_002_sensor_pathはマスタなので、実データがない場合もある
                        # lon, latで登録
                        _geom = QgsGeometry.fromPointXY(QgsPointXY(float(f_row[2]), float(f_row[1])))
                        feature2 = QgsFeature(new_layer.fields())
                        feature2.setGeometry(_geom)
                        feature2[0] = sensor_id

                        sensor_value = self.point_geo_features[sensor_id] # value：計測点の集計値
                        feature2[1] = sensor_value

                        feature2[2] = f_row[3]
                        if len(f_row) > 4 :
                            feature2[3] = f_row[4]
                        if len(f_row) > 5 :
                            feature2[4] = f_row[5]
                        if len(f_row) > 6 :
                            feature2[5] = f_row[6]
                        if len(f_row) > 7 :
                            feature2[6] = f_row[7]
                        if len(f_row) > 8 :
                            feature2[7] = f_row[8]

                        new_layer.addFeature(feature2)

                        if circle_max == None:
                            circle_max = sensor_value
                        else:
                            if sensor_value > circle_max:
                                circle_max = sensor_value
                        if circle_min == None:
                            circle_min = sensor_value
                        else:
                            if sensor_value < circle_min:
                                circle_min = sensor_value

                    i=i+1

            new_layer.commitChanges()

            if new_layer.featureCount() <= 0:
                progress.close()
                QMessageBox.warning(None, "分析処理", "該当レコードがありません")
                return

            # 3.geojsonとして出力
            # ※センサー情報(位置情報)がない場合でも出力
            QgsVectorFileWriter.writeAsVectorFormat(
                new_layer,
                os.path.dirname(__file__) + '/temp/result_002.geojson',
                'UTF-8',
                QgsCoordinateReferenceSystem("EPSG:4326"),
                'GeoJSON'
            )

            # htmlテンプレートの取得と文字置換
            url = os.path.dirname(__file__)+"/html/002.html" # htmlテンプレート

            # 計測点独自の情報
            # 1.計測点のIDリスト文字列
            # 数値でソートもする
            point_id_list = list(self.point_geo_features.keys())
            point_id_int_list = []
            #for p_id in point_id_list:
            #    point_id_int_list.append(int(p_id))
            point_id_int_list = sorted(point_id_int_list)

            point_ids = ','.join("'" + str(s) + "'" for s in point_id_list) # シングルクォーテーションもつける

            # 2.グラフデータ
            graph_data = self.file_002_term_data_1
            graph_data_2 = self.file_002_term_data_2

            # 3.地図上の計測点の色
            # 'graph_item[0], color(graph_item[0]),graph_item[1], color(graph_item[1])'
            # graph_item:htmlで定義した変数
            paint_str = ""
            for i in range(len(self.point_geo_features)):
                paint_str += 'graph_item[' + str(i) +'], color(graph_item['+ str(i) +']),'
            paint_str += "'#ccc'" # 不明の場合の色

            # 4.凡例のhtml
            legend_div = ""
            for p_id in point_id_list:
                legend_div += '<div class="grapy_legend"><span id="sp_'+ str(p_id) +'">　</span> ' + self.file_002_point_name_list[str(p_id)] + '</div>'

            self.replaceData(
                    url, 
                    os.path.dirname(__file__) + '/temp/result_002.geojson', 
                    [
                        point_ids, 
                        graph_data, 
                        graph_data_2, 
                        paint_str,
                        legend_div,
                        [circle_max, circle_min] # 円の大きさrangeを決めるため
                    ],
                    True,
                    False
                    )
            url = url + ".html" # 置換ファイル
            QMessageBox.information(None, "分析処理", "分析処理が完了しました。")
            self.move_002_6()

            self.btn_002_5_n.setVisible(True)
            self.lbl_002_5_n.setVisible(True)
            progress.close()
            QgsProject.instance().removeMapLayer(new_layer.id())

            self.iface.mapCanvas().refresh()
        
        except :
            progress.close()
            QMessageBox.warning(None, "分析処理", "分析処理時に問題が発生しました")

    def export_html_002_clicked(self):
        # ダイアログ表示
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                    os.path.expanduser('~') + '/Desktop','HTML file(*.html)')
        url = os.path.dirname(__file__)+"/html/002.html"

        try:
            if output_path[0] :
                shutil.copyfile(url+".html", output_path[0])
                url = output_path[0]

                subprocess.Popen(['start', url], shell=True)
        except:
            QMessageBox.warning(None, "HTML保存", "HTML保存時に問題が発生しました")        

    def export_csv_002_clicked(self):
        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','CSV(*.csv)')
        try:
            if output_path[0] :                                   
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer1,
                    output_path[0],
                    'UTF-8',
                    QgsCoordinateReferenceSystem("EPSG:4326"),
                    'CSV'
                )
        except:
            QMessageBox.warning(None, "CSV保存", "CSV保存時に問題が発生しました")        

    def export_geojson_002_clicked(self):
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','GeoJson(*.geojson)')
        try:
            if output_path[0] :
                shutil.copyfile(os.path.dirname(__file__) + '/temp/result_002.geojson', output_path[0])
        except:
            QMessageBox.warning(None, "geojson保存", "geojson保存時に問題が発生しました")        


    def sensor_read_003_clicked(self):
        try:
            # センサー情報の読み込み
            (fileName, selectedFilter) = QFileDialog.getOpenFileName(self, '指定エリア情報', 
                                self.default_file_path, "指定エリア情報csv (*.csv)")

            # self.file_002_sensor_reader = None
            if fileName != None and fileName != "":
                self.default_file_path = os.path.dirname(fileName)
                #ヘッダー確認
                file_encoding = encodingCheck(fileName)
                if "error" in file_encoding :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   

                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)

                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return        
                if len(header) < 3:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if len(header) > 8:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if header[0] != "area" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(area)")
                    return
                if header[1] != "lat" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lat)")
                    return
                if header[2] != "lon" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lon)")
                    return                
                if len(header) > 3:
                    if header[3] != "option1" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option1)")
                        return
                if len(header) > 4:
                    if header[4] != "option2" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option2)")
                        return
                if len(header) > 5:
                    if header[5] != "option3" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option3)")
                        return
                if len(header) > 6:
                    if header[6] != "option4" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option4)")
                        return
                if len(header) > 7:
                    if header[7] != "option5" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option5)")
                        return

                if sum([1 for _ in open(fileName, encoding=file_encoding, newline='')]) == 1:
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return

                place_id_list = []
                with open(fileName, encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    i = 0
                    for row in reader:
                        if i == 0:
                            i=i+1
                            continue
                        if row[0] == "" :
                            QMessageBox.warning(None, "CSVチェック", "areaが指定されていません")
                            return
                        if row[1] == "" :
                            QMessageBox.warning(None, "CSVチェック", "latが指定されていません")
                            return
                        if row[2] == "" :
                            QMessageBox.warning(None, "CSVチェック", "lonが指定されていません")
                            return

                        place_id_list.append(row[0])
                        # 座標値チェック
                        float(row[1])
                        float(row[2])
                        if (float(row[1]) <= -90) or (float(row[1]) >= 90) :
                            float(row[1] + 'a')
                        if (float(row[2]) <= -180) or (float(row[2]) >= 180) :
                            float(row[2] + 'a')     
                        
                        i=i+1

                if len(place_id_list) != len(set(place_id_list)) :
                    QMessageBox.warning(None, "CSVチェック", "areaが重複しています")
                    return

                self.area_id_list = place_id_list

                file_path = fileName
                file_name = file_path[file_path.rfind("/") + 1:]
                self.lbl_003_filename_2.setText(file_name)

                self.file_003_sensor_path = fileName


                self.lbl_002_sensor_msg_2.setText("エリア情報の読み込みに成功しました。")
                self.btn_003_2_n.setVisible(True)
                self.lbl_003_2_n.setVisible(True)
        except ValueError as e:
            QMessageBox.warning(None, "CSVチェック", "センサー情報の座標が登録できません")
        except:
            QMessageBox.warning(None, "エリア情報読み込み", "ファイル読み込み時に問題が発生しました")      

    def csv_read_003_clicked(self):
        try:
            (fileName, selectedFilter) = QFileDialog.getOpenFileName(self, '移動滞在ログデータ選択', 
                                self.default_file_path, "移動滞在ログデータcsv (*.csv)")

            if fileName != None and fileName != "":
                self.default_file_path = os.path.dirname(fileName)
                progress = QProgressDialog('処理しています...', '', 0, 0, None)
                progress.setWindowModality(Qt.ApplicationModal)
                progress.setCancelButton(None)
                progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
                progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
                progress.show()

                QApplication.processEvents()
                file_encoding = encodingCheck(fileName)
                if "error" in file_encoding :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                
                

                if len(header) < 6:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if len(header) > 11:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return

                self.header_count = len(header)
                if header[0] != "time_o" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(time_o)")
                    return
                if header[1] != "time_d" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(time_d)")
                    return
                if header[2] != "origin" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(origin)")
                    return
                if header[3] != "destination" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(destination)")
                    return
                if header[4] != "id" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(id)")
                    return
                if header[5] != "value" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(value)")
                    return
                if len(header) > 6:
                    if header[6] != "option1" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option1)")
                        return
                if len(header) > 7:
                    if header[7] != "option2" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option2)")
                        return
                if len(header) > 8:
                    if header[8] != "option3" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option3)")
                        return
                if len(header) > 9:
                    if header[9] != "option4" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option4)")
                        return
                if len(header) > 10:
                    if header[10] != "option5" :
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option5)")
                        return

                if sum([1 for _ in open(fileName, encoding=file_encoding, newline='')]) == 1:
                    progress.close()
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return

                # ファイル読み込み
                with open(fileName, encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    i=0
                    for row in reader:
                        # ヘッダーがある前提でスキップ
                        if i == 0:
                            i=i+1
                            continue
                        if row[2] == "":
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "originが指定されていません")
                            return 
                        if row[3] == "":
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "destinationが指定されていません")
                            return 

                        if not(row[2] in self.area_id_list) :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "originがエリアと一致しません")
                            return 

                        if not(row[3] in self.area_id_list) :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "destinationがエリアと一致しません")
                            return 

                file_path = fileName
                file_name = file_path[file_path.rfind("/") + 1:]
                self.lbl_002_filename_2.setText(file_name)


                if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
                    QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())

                csvLyr = QgsVectorLayer('None', 'csv', 'memory')
                csvLyrprov = csvLyr.dataProvider()   
                csvLyr.setProviderEncoding('UTF-8')
                csvLyr.dataProvider().setEncoding('UTF-8')   
                QgsProject.instance().addMapLayers([csvLyr])

                csvLyrprov.addAttributes([QgsField("time_o", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("time_d", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("origin", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("destination", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("id", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("value", QVariant.Double)])                
                for i in range(0,self.header_count-6):
                    csvLyrprov.addAttributes([QgsField("option" + str(i+1), QVariant.String)])
                csvLyr.updateFields()

                featureList = []
                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                    for row in csvreader:
                        float(row[5])
                        feat = QgsFeature()
                        feat.setAttributes(row)
                        featureList.append(feat)
                
                csvLyr.dataProvider().addFeatures(featureList)        
                csvLyr.commitChanges()


                layer1 = csvLyr

                option_list = []
                for cnt in range(0,self.header_count-6) :
                    option = processing.run("qgis:listuniquevalues", {'INPUT':layer1,'FIELDS':['option'+str(cnt+1)],'OUTPUT':'TEMPORARY_OUTPUT'})
                    option_list_temp = []
                    for item in option["OUTPUT"].getFeatures():
                        option_list_temp.append(item.attributes()[0])
                    option_list.append(option_list_temp)


                self.cmb_option1_3.setVisible(False)
                self.lbl_option1_3.setVisible(False)
                self.cmb_option2_3.setVisible(False)
                self.lbl_option2_3.setVisible(False)
                self.cmb_option3_3.setVisible(False)
                self.lbl_option3_3.setVisible(False)
                self.cmb_option4_3.setVisible(False)
                self.lbl_option4_3.setVisible(False)
                self.cmb_option5_3.setVisible(False)
                self.lbl_option5_3.setVisible(False)


                self.len = len(option_list)

                if self.len >= 1 : 
                    self.cmb_option1_3.clear()
                    self.cmb_option1_3.addItem('ALL')
                    self.cmb_option1_3.addItems(option_list[0])
                    self.cmb_option1_3.model().sort(0)
                    self.cmb_option1_3.setVisible(True)
                    self.lbl_option1_3.setVisible(True)
                if self.len >= 2 : 
                    self.cmb_option2_3.clear()
                    self.cmb_option2_3.addItem('ALL')
                    self.cmb_option2_3.addItems(option_list[1])
                    self.cmb_option2_3.model().sort(0)
                    self.cmb_option2_3.setVisible(True)
                    self.lbl_option2_3.setVisible(True)
                if self.len >= 3 : 
                    self.cmb_option3_3.clear()
                    self.cmb_option3_3.addItem('ALL')
                    self.cmb_option3_3.addItems(option_list[2])
                    self.cmb_option3_3.model().sort(0)
                    self.cmb_option3_3.setVisible(True)
                    self.lbl_option3_3.setVisible(True)
                if self.len >= 4 : 
                    self.cmb_option4_3.clear()
                    self.cmb_option4_3.addItem('ALL')
                    self.cmb_option4_3.addItems(option_list[3])
                    self.cmb_option4_3.model().sort(0)
                    self.cmb_option4_3.setVisible(True)
                    self.lbl_option4_3.setVisible(True)
                if self.len >= 5 : 
                    self.cmb_option5_3.clear()
                    self.cmb_option5_3.addItem('ALL')
                    self.cmb_option5_3.addItems(option_list[4])
                    self.cmb_option5_3.model().sort(0)
                    self.cmb_option5_3.setVisible(True)
                    self.lbl_option5_3.setVisible(True)



                progress.close()

                self.lbl_002_read_msg_2.setText("移動滞在ログデータの読み込みに成功しました。")
                
                self.file_003_name = file_name

                self.btn_003_3_n.setVisible(True)
                self.lbl_003_3_n.setVisible(True)

        except ValueError as e:
            progress.close()
            QMessageBox.warning(None, "CSVチェック", "フィールド(value)の値を数値として保存できませんでした")

        except :
            progress.close()
            QMessageBox.warning(None, "移動滞在ログデータ読み込み", "ファイル読み込み時に問題が発生しました")

    def btn_option_load_3_clicked(self):
        try:
            self.lbl_001_11.setText('')
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:
                self.default_file_path = os.path.dirname(fname[0])
                self.list_optioncsv_3.clear()

                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :

                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                

                if len(header) != 2:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                if header[0] != "option" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                    return

                if header[1] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return


                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l_0 = [rows[0] for rows in reader]

                if len(l_0) != len(set(l_0)) :
                    QMessageBox.warning(None, "CSVチェック", "optionが重複しています")
                    return  
                
                for lv in l_0 :
                    if not(lv in ['option','option1','option2','option3','option4','option5']) :
                        QMessageBox.warning(None, "CSVチェック", "option1-5以外の項目が設定されています")
                        return 
                
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l = {rows[0]:rows[1] for rows in reader}

                self.colName = l

                self.lbl_option1_3.setText(self.colName.get('option1', 'option1'))
                self.lbl_option2_3.setText(self.colName.get('option2', 'option2'))
                self.lbl_option3_3.setText(self.colName.get('option3', 'option3'))
                self.lbl_option4_3.setText(self.colName.get('option4', 'option4'))
                self.lbl_option5_3.setText(self.colName.get('option5', 'option5'))

                self.list_optioncsv_3.addItem(os.path.basename(fname[0]))
                self.lbl_001_11.setText('オプション情報の読み込みに成功しました。')

            else :
                self.list_optioncsv_3.clear()
                self.lbl_001_11.setText('')
                self.colName = {}
        except:
            QMessageBox.warning(None, "オプション情報読み込み", "ファイル読み込み時に問題が発生しました")

    def web_003_clicked(self):
        try:
            self.lbl_001_9.setText('')
            self.btn_003_4_n.setVisible(False)
            self.lbl_003_4_n.setVisible(False)

            progress = QProgressDialog('処理しています...', '', 0, 0, None)
            progress.setWindowModality(Qt.ApplicationModal)
            progress.setCancelButton(None)
            progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
            progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
            progress.show()

            QApplication.processEvents()

            layer1 = QgsProject.instance().mapLayersByName('csv')[0]
            filter_list = []
            if self.len >= 1 : filter_list.append(str(self.cmb_option1_3.currentText()))
            if self.len >= 2 : filter_list.append(str(self.cmb_option2_3.currentText()))
            if self.len >= 3 : filter_list.append(str(self.cmb_option3_3.currentText()))
            if self.len >= 4 : filter_list.append(str(self.cmb_option4_3.currentText()))
            if self.len >= 5 : filter_list.append(str(self.cmb_option5_3.currentText()))

            sfilter = ""
            self.filter = {}

            alist = []
            for cnt in range(self.header_count-6) :
                if cnt == 0:
                    if filter_list[0] == 'ALL' :
                        alist.append("option1")
                    else :
                        sfilter += "\"option1\" = '%s'" % (filter_list[0])
                    self.filter["option1"] = [self.colName.get('option1', 'option1'),filter_list[0]]
                else:
                    if filter_list[cnt] == 'ALL' :
                        alist.append("option" + str(cnt+1))
                    else :
                        if sfilter == "" :
                            sfilter +=  "\"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                        else :    
                            sfilter +=  " AND \"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                    self.filter["option" + str(cnt+1)] = [self.colName.get("option" + str(cnt+1), "option" + str(cnt+1)),filter_list[cnt]]
            layer1.setSubsetString(sfilter)

            QApplication.processEvents()

            if layer1.featureCount() <= 0:
                progress.close()
                QMessageBox.warning(None, "分析処理", "該当レコードがありません")
                return  


            QApplication.processEvents()

            if len(QgsProject.instance().mapLayersByName('result')) >= 1 :
                QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('result')[0].id())


            new_layer = QgsVectorLayer("point", "result", "memory")
            QgsProject.instance().addMapLayer(new_layer)
            prov = new_layer.dataProvider()
            caps = prov.capabilities()
            if caps & QgsVectorDataProvider.AddAttributes:
                prov.addAttributes(
                    [
                        QgsField('area', QVariant.String),
                        QgsField('option1', QVariant.String),
                        QgsField('option2', QVariant.String),
                        QgsField('option3', QVariant.String),
                        QgsField('option4', QVariant.String),
                        QgsField('option5', QVariant.String)
                    ])
                new_layer.updateFields()

            new_layer.startEditing()
            # for feat in _layer.getFeatures():
            select_value = []
            file_encoding = encodingCheck(self.file_003_sensor_path)
            with open(self.file_003_sensor_path, encoding=file_encoding, newline='') as f:
                reader = csv.reader(f)
                i=0
                for f_row in reader:
                    # ヘッダーがある前提でスキップ
                    if i == 0:
                        i=i+1
                        continue
                    if i == 1:
                        select_value = f_row
                    # lon, latで登録
                    _geom = QgsGeometry.fromPointXY(QgsPointXY(float(f_row[2]), float(f_row[1])))
                    feature2 = QgsFeature(new_layer.fields())
                    feature2.setGeometry(_geom)
                    feature2[0] = f_row[0]
                    if len(f_row) > 3 :
                        feature2[1] = f_row[3]
                    if len(f_row) > 4 :
                        feature2[2] = f_row[4]
                    if len(f_row) > 5 :
                        feature2[3] = f_row[5]
                    if len(f_row) > 6 :
                        feature2[4] = f_row[6]
                    if len(f_row) > 7 :
                        feature2[5] = f_row[7]

                    new_layer.addFeature(feature2)

                    i=i+1

                new_layer.commitChanges()

                QgsVectorFileWriter.writeAsVectorFormat(
                    new_layer,
                    os.path.dirname(__file__) + '/temp/result_003.geojson',
                    'UTF-8',
                    QgsCoordinateReferenceSystem("EPSG:4326"),
                    'GeoJSON'
                )

            if self.replaceData_003(select_value) :
                #self.do_crosstab_time()
                progress.close()
                QMessageBox.information(None, "分析処理", "分析処理が完了しました。")
                self.move_003_5()
                self.btn_003_4_n.setVisible(True)
                self.lbl_003_4_n.setVisible(True)
            else :
                progress.close()
                QMessageBox.warning(None, "分析処理", "クロス集計に失敗しました")

        except KeyError as e:
            progress.close()
            QMessageBox.warning(None, "分析処理", "クロス集計に失敗しました")
            
        except :
            progress.close()
            QMessageBox.warning(None, "分析処理", "分析処理時に問題が発生しました")

    def export_html_003_clicked(self):
        # ダイアログ表示
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                    os.path.expanduser('~') + '/Desktop','HTML file(*.html)')
        url = os.path.dirname(__file__)+"/html/003.html"
        try:  
            if output_path[0] :
                shutil.copyfile(url+".html", output_path[0])
                url = output_path[0]

                subprocess.Popen(['start', url], shell=True)
        except:
            QMessageBox.warning(None, "html保存", "html保存時に問題が発生しました")        

    def export_csv_003_clicked(self):
        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','CSV(*.csv)')
        try:
            if output_path[0] :
                shutil.copyfile(os.path.dirname(__file__) + '/temp/result_003_csv_001.csv', output_path[0])
        except:
            QMessageBox.warning(None, "csv保存", "csv保存時に問題が発生しました")        

    def export_geojson_003_clicked(self):
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','GeoJson(*.geojson)')
        try:
            if output_path[0] :
                shutil.copyfile(os.path.dirname(__file__) + '/temp/origin.geojson', output_path[0])
        except:
            QMessageBox.warning(None, "geojson保存", "geojson保存時に問題が発生しました")        

    #def export_geojson_003_2_clicked(self):
    #    output_path = QFileDialog.getSaveFileName(self, "保存先指定",
    #                                   os.path.expanduser('~') + '/Desktop','GeoJson(*.geojson)')
    #    try:
    #        if output_path[0] :
    #            shutil.copyfile(os.path.dirname(__file__) + '/temp/destination.geojson', output_path[0])
    #    except:
    #        QMessageBox.warning(None, "geojson保存", "geojson保存時に問題が発生しました")        


    def sensor_read_003_2_clicked(self):
        try:
            (fileName, selectedFilter) = QFileDialog.getOpenFileName(self, 'ログデータ選択', 
                                self.default_file_path, "ログデータcsv (*.csv)")

            zahyo_flag = 0
            if fileName != None and fileName != "":

                progress = QProgressDialog('処理しています...', '', 0, 0, None)
                progress.setWindowModality(Qt.ApplicationModal)
                progress.setCancelButton(None)
                progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
                progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
                progress.show()

                QApplication.processEvents()

                self.default_file_path = os.path.dirname(fileName)
                #ヘッダー確認
                file_encoding = encodingCheck(fileName)
                if "error" in file_encoding :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   

                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)

                if len(header) != len(set(header)) :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return        
                if len(header) < 4:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if len(header) > 9:
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                if header[0] != "id" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(id)")
                    return
                if header[1] != "timestamp" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(timestamp)")
                    return
                if header[2] != "lat" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lat)")
                    return
                if header[3] != "lon" :
                    progress.close()
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(lon)")
                    return                
                if len(header) > 4:
                    if header[4] != "option1" :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option1)")
                        return
                if len(header) > 5:
                    if header[5] != "option2" :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option2)")
                        return
                if len(header) > 6:
                    if header[6] != "option3" :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option3)")
                        return
                if len(header) > 7:
                    if header[7] != "option4" :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option4)")
                        return
                if len(header) > 8:
                    if header[8] != "option5" :
                        progress.close()
                        QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option5)")
                        return

                if sum([1 for _ in open(fileName, encoding=file_encoding, newline='')]) == 1:
                    progress.close()
                    QMessageBox.warning(None, "CSVチェック", "CSVデータが取得できませんでした")
                    return
                
                self.header_count = len(header)

                with open(fileName, encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    i = 0
                    for row in reader:
                        if i == 0:
                            i=i+1
                            continue
                        if row[0] == "" :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "idが指定されていません")
                            return
                        if row[1] == "" :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "timestampが指定されていません")
                            return
                        if row[2] == "" :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "latが指定されていません")
                            return
                        if row[3] == "" :
                            progress.close()
                            QMessageBox.warning(None, "CSVチェック", "lonが指定されていません")
                            return

                        # 座標値チェック
                        zahyo_flag = 0
                        float(row[2])
                        float(row[3])
                        if (float(row[2]) <= -90) or (float(row[2]) >= 90) :
                            float(row[2] + 'a')
                        if (float(row[3]) <= -180) or (float(row[3]) >= 180) :
                            float(row[3] + 'a')     
                        zahyo_flag = 1
                        i=i+1

                # ログCSV読み込み
                if len(QgsProject.instance().mapLayersByName('csv')) >= 1 :
                    QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('csv')[0].id())

                csvLyr = QgsVectorLayer('None', 'csv', 'memory')
                csvLyrprov = csvLyr.dataProvider()   
                csvLyr.setProviderEncoding('UTF-8')
                csvLyr.dataProvider().setEncoding('UTF-8')   
                QgsProject.instance().addMapLayers([csvLyr])

                csvLyrprov.addAttributes([QgsField("id", QVariant.String)])
                csvLyrprov.addAttributes([QgsField("timestamp", QVariant.DateTime)])
                csvLyrprov.addAttributes([QgsField("lat", QVariant.Double)])
                csvLyrprov.addAttributes([QgsField("lon", QVariant.Double)])
                for i in range(0,self.header_count-4):
                    csvLyrprov.addAttributes([QgsField("option" + str(i+1), QVariant.String)])
                    
                csvLyr.updateFields()
                featureList = []
                with open(fileName, encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                    for row in csvreader:
                        feat = QgsFeature()
                        feat.setAttributes(row)
                        featureList.append(feat)
                    
                csvLyr.dataProvider().addFeatures(featureList)        
                csvLyr.commitChanges()
                
                layer1 = csvLyr


                option_list = []
                for cnt in range(0,self.header_count-4) :
                    option = processing.run("qgis:listuniquevalues", {'INPUT':layer1,'FIELDS':['option'+str(cnt+1)],'OUTPUT':'TEMPORARY_OUTPUT'})
                    option_list_temp = []
                    for item in option["OUTPUT"].getFeatures():
                        option_list_temp.append(item.attributes()[0])
                    option_list.append(option_list_temp)


                self.cmb_option1_4.setVisible(False)
                self.lbl_option1_4.setVisible(False)
                self.cmb_option2_4.setVisible(False)
                self.lbl_option2_4.setVisible(False)
                self.cmb_option3_4.setVisible(False)
                self.lbl_option3_4.setVisible(False)
                self.cmb_option4_4.setVisible(False)
                self.lbl_option4_4.setVisible(False)
                self.cmb_option5_4.setVisible(False)
                self.lbl_option5_4.setVisible(False)

                self.len = len(option_list)

                if self.len >= 1 : 
                    self.cmb_option1_4.clear()
                    self.cmb_option1_4.addItem('ALL')
                    self.cmb_option1_4.addItems(option_list[0])
                    self.cmb_option1_4.model().sort(0)
                    self.cmb_option1_4.setVisible(True)
                    self.lbl_option1_4.setVisible(True)
                if self.len >= 2 : 
                    self.cmb_option2_4.clear()
                    self.cmb_option2_4.addItem('ALL')
                    self.cmb_option2_4.addItems(option_list[1])
                    self.cmb_option2_4.model().sort(0)
                    self.cmb_option2_4.setVisible(True)
                    self.lbl_option2_4.setVisible(True)
                if self.len >= 3 : 
                    self.cmb_option3_4.clear()
                    self.cmb_option3_4.addItem('ALL')
                    self.cmb_option3_4.addItems(option_list[2])
                    self.cmb_option3_4.model().sort(0)
                    self.cmb_option3_4.setVisible(True)
                    self.lbl_option3_4.setVisible(True)
                if self.len >= 4 : 
                    self.cmb_option4_4.clear()
                    self.cmb_option4_4.addItem('ALL')
                    self.cmb_option4_4.addItems(option_list[3])
                    self.cmb_option4_4.model().sort(0)
                    self.cmb_option4_4.setVisible(True)
                    self.lbl_option4_4.setVisible(True)
                if self.len >= 5 : 
                    self.cmb_option5_4.clear()
                    self.cmb_option5_4.addItem('ALL')
                    self.cmb_option5_4.addItems(option_list[4])
                    self.cmb_option5_4.model().sort(0)
                    self.cmb_option5_4.setVisible(True)
                    self.lbl_option5_4.setVisible(True)
                
                file_path = fileName
                file_name = file_path[file_path.rfind("/") + 1:]
                self.lbl_003_filename_3.setText(file_name)

                progress.close()
                self.lbl_002_sensor_msg_3.setText("ログデータの読み込みに成功しました。")
                self.btn_003_7_n.setVisible(True)
                self.lbl_003_7_n.setVisible(True)
        except ValueError as e:
            progress.close()
            if zahyo_flag == 0:
                QMessageBox.warning(None, "CSVチェック", "ログデータの座標が登録できません")
            if zahyo_flag == 1:
                QMessageBox.warning(None, "CSVチェック", "ログデータのタイムスタンプが登録できません")
        except:
            progress.close()
            QMessageBox.warning(None, "ログデータ読み込み", "ファイル読み込み時に問題が発生しました")      

    def btn_option_load_4_clicked(self):
        try:
            self.lbl_001_12.setText('')
            fname = QFileDialog.getOpenFileName(self, 'ファイル選択', self.default_file_path,"csv (*.csv)")
            if fname[0]:
                self.default_file_path = os.path.dirname(fname[0])
                self.list_optioncsv_4.clear()

                file_encoding = encodingCheck(fname[0])
                if "error" in file_encoding :

                    QMessageBox.warning(None, "CSVフォーマットチェック", "文字コードが対応していません(" + file_encoding +")")
                    return   
                #ヘッダー確認
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    csvreader = csv.reader(f)
                    header = next(csvreader)
                
                if len(header) != len(set(header)) :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "項目名が重複しています")
                    return                

                if len(header) != 2:
                    QMessageBox.warning(None, "CSVフォーマットチェック", "フィールド数が異なります")
                    return
                
                if header[0] != "option" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(option)")
                    return

                if header[1] != "name" :
                    QMessageBox.warning(None, "CSVフォーマットチェック", "CSVの形式が異なります(name)")
                    return


                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l_0 = [rows[0] for rows in reader]

                if len(l_0) != len(set(l_0)) :
                    QMessageBox.warning(None, "CSVチェック", "optionが重複しています")
                    return  
                
                for lv in l_0 :
                    if not(lv in ['option','option1','option2','option3','option4','option5']) :
                        QMessageBox.warning(None, "CSVチェック", "option1-5以外の項目が設定されています")
                        return 
                
                with open(fname[0], encoding=file_encoding, newline='') as f:
                    reader = csv.reader(f)
                    l = {rows[0]:rows[1] for rows in reader}

                self.colName = l

                self.lbl_option1_4.setText(self.colName.get('option1', 'option1'))
                self.lbl_option2_4.setText(self.colName.get('option2', 'option2'))
                self.lbl_option3_4.setText(self.colName.get('option3', 'option3'))
                self.lbl_option4_4.setText(self.colName.get('option4', 'option4'))
                self.lbl_option5_4.setText(self.colName.get('option5', 'option5'))

                self.list_optioncsv_4.addItem(os.path.basename(fname[0]))
                self.lbl_001_12.setText('オプション情報の読み込みに成功しました。')

            else :
                self.list_optioncsv_4.clear()
                self.lbl_001_12.setText('')
                self.colName = {}
        except:
            QMessageBox.warning(None, "オプション情報読み込み", "ファイル読み込み時に問題が発生しました")

    def web_003_2_clicked(self):
        try:
            self.lbl_001_10.setText('')
            self.btn_003_8_n.setVisible(False)
            self.lbl_003_8_n.setVisible(False)

            progress = QProgressDialog('処理しています...', '', 0, 0, None)
            progress.setWindowModality(Qt.ApplicationModal)
            progress.setCancelButton(None)
            progress.setWindowFlag(Qt.WindowContextHelpButtonHint, False)
            progress.setWindowFlag(Qt.WindowCloseButtonHint, False)
            progress.show()

            QApplication.processEvents()

            layer1 = QgsProject.instance().mapLayersByName('csv')[0]
            filter_list = []
            if self.len >= 1 : filter_list.append(str(self.cmb_option1_4.currentText()))
            if self.len >= 2 : filter_list.append(str(self.cmb_option2_4.currentText()))
            if self.len >= 3 : filter_list.append(str(self.cmb_option3_4.currentText()))
            if self.len >= 4 : filter_list.append(str(self.cmb_option4_4.currentText()))
            if self.len >= 5 : filter_list.append(str(self.cmb_option5_4.currentText()))

            sfilter = ""
            self.filter = {}

            alist = []
            for cnt in range(self.header_count-4) :
                if cnt == 0:
                    if filter_list[0] == 'ALL' :
                        alist.append("option1")
                    else :
                        sfilter += "\"option1\" = '%s'" % (filter_list[0])
                    self.filter["option1"] = [self.colName.get('option1', 'option1'),filter_list[0]]
                else:
                    if filter_list[cnt] == 'ALL' :
                        alist.append("option" + str(cnt+1))
                    else :
                        if sfilter == "" :
                            sfilter +=  "\"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                        else :    
                            sfilter +=  " AND \"option%s\" = '%s'" % (cnt+1,filter_list[cnt])
                    self.filter["option" + str(cnt+1)] = [self.colName.get("option" + str(cnt+1), "option" + str(cnt+1)),filter_list[cnt]]

            layer1.setSubsetString(sfilter)

            QApplication.processEvents()

            if layer1.featureCount() <= 0:
                progress.close()
                QMessageBox.warning(None, "分析処理", "該当レコードがありません")
                return  


            QApplication.processEvents()

            if self.replaceData_004() :
                progress.close()
                QMessageBox.information(None, "分析処理", "分析処理が完了しました。")
                self.move_003_9()
                self.btn_003_8_n.setVisible(True)
                self.lbl_003_8_n.setVisible(True)
            else :
                progress.close()
                QMessageBox.warning(None, "分析処理", "時系列データの作成に失敗しました")
           
        except :
            progress.close()
            QMessageBox.warning(None, "分析処理", "分析処理時に問題が発生しました")

    def export_html_003_2_clicked(self):
        # ダイアログ表示
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                    os.path.expanduser('~') + '/Desktop','HTML file(*.html)')
        url = os.path.dirname(__file__)+"/html/003-2.html"
        try:  
            if output_path[0] :
                shutil.copyfile(url+".html", output_path[0])
                url = output_path[0]

                subprocess.Popen(['start', url], shell=True)
        except:
            QMessageBox.warning(None, "html保存", "html保存時に問題が発生しました")

    def export_csv_003_2_clicked(self):
        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','CSV(*.csv)')
        try:
            if output_path[0] :                                   
                QgsVectorFileWriter.writeAsVectorFormat(
                    layer1,
                    output_path[0],
                    'UTF-8',
                    QgsCoordinateReferenceSystem("EPSG:4326"),
                    'CSV'
                )
        except:
            QMessageBox.warning(None, "CSV保存", "CSV保存時に問題が発生しました")

    def export_geojson_003_3_clicked(self):
        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        output_path = QFileDialog.getSaveFileName(self, "保存先指定",
                                       os.path.expanduser('~') + '/Desktop','GeoJson(*.geojson)')
        try:
            if output_path[0] :
                result = processing.run("native:geometrybyexpression", 
                    {'INPUT':layer1,'OUTPUT_GEOMETRY':2,'WITH_Z':False,'WITH_M':False,'EXPRESSION':'make_point("lon" , "lat" ) ','OUTPUT':'TEMPORARY_OUTPUT'})

                QgsVectorFileWriter.writeAsVectorFormat(
                    result["OUTPUT"],
                    output_path[0],
                    'UTF-8',
                    QgsCoordinateReferenceSystem("EPSG:4326"),
                    'GeoJSON'
                )
        except:
            QMessageBox.warning(None, "geojson保存", "geojson保存時に問題が発生しました")  

    def datajoin(self,alist) :
        layer1 = QgsProject.instance().mapLayersByName('sptial')[0]
        layer2 = QgsProject.instance().mapLayersByName('csv')[0]
        
        if len(alist) != 0 :
            aggregate_list = []
            for cnt in range(0,self.header_count):
                if cnt == 0 :
                    m = {'aggregate': 'first_value','delimiter': ',','input': '"meshcode"','length': 0,'name': 'meshcode','precision': 0,'type': 10}
                elif  cnt == self.header_count-1 : 
                    m = {'aggregate': 'sum','delimiter': ',','input': '"value"','length': 0,'name': 'value','precision': 0,'type': 6}
                else :
                    m = {'aggregate': 'first_value','delimiter': ',','input': '"option'+str(cnt)+'"','length': 0,'name': 'option'+str(cnt),'precision': 0,'type': 10}
            
                aggregate_list.append(m)
            
            result_csv = processing.run("native:aggregate", {'INPUT':layer2,'GROUP_BY':'"meshcode"','AGGREGATES':aggregate_list,'OUTPUT':'TEMPORARY_OUTPUT'})
            layer2 = result_csv["OUTPUT"]
        
        result = processing.run("native:joinattributestable", {'INPUT':layer1,'FIELD':'meshcode','INPUT_2':layer2,'FIELD_2':'meshcode','FIELDS_TO_COPY':["value"],'METHOD':1,'DISCARD_NONMATCHING':False,'PREFIX':'','OUTPUT':'TEMPORARY_OUTPUT'})
        result["OUTPUT"].setProviderEncoding('UTF-8')
        result["OUTPUT"].dataProvider().setEncoding('UTF-8')
        QgsVectorFileWriter.writeAsVectorFormatV2(
            result["OUTPUT"],
            os.path.dirname(__file__) + '/temp/result.gpkg',
            QgsProject.instance().transformContext(),
            QgsVectorFileWriter.SaveVectorOptions()
        )
        QgsVectorFileWriter.writeAsVectorFormat(
            layer2,
            os.path.dirname(__file__) + '/temp/result.csv',
            'UTF-8',
            QgsCoordinateReferenceSystem("EPSG:4326"),
            'CSV'
        )
        #QgsProject.instance().removeMapLayer(layer1.id())
        #QgsProject.instance().removeMapLayer(layer2.id())


    def replaceData(self,path,geo_json_path, graph_datas=None, add_id_flg=False,legend_flg=False) :

        layer = QgsProject.instance().mapLayersByName('result')[0]
        ext = layer.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        coords = "%f,%f" %((xmin+xmax)/2.0, (ymin+ymax)/2.0) 
        bound1 = "%f,%f" %(xmin,ymin) 
        bound2 = "%f,%f" %(xmax,ymax)

        self.iface.mapCanvas().setExtent(ext)

        zoom = getZoomFromScale(self.iface.mapCanvas().scale())

        f = open(geo_json_path, 'r')
        str_geojson = f.read()
        f.close()

        if add_id_flg == True:
            # featuresにidを付与する
            temp_geojson = json.loads(str_geojson)
            features = temp_geojson['features']
            # print("features before", temp_geojson['features'][0])
            i_id = 1
            for feat in features:
                # 一意性を確保するため順番に付与する
                feat['id']  = i_id
                i_id += 1
            str_geojson = json.dumps(temp_geojson)

        file_name = path
        with open(file_name, encoding="utf-8") as f:
            data_lines = f.read()

        data_lines = data_lines.replace("data_replace", str_geojson)
        data_lines = data_lines.replace("center_replace", coords)
        data_lines = data_lines.replace("zoom_replace", str(zoom))
        data_lines = data_lines.replace("bound_replace_1", bound1)
        data_lines = data_lines.replace("bound_replace_2", bound2)

        if graph_datas != None and len(graph_datas) >= 6:
            data_lines = data_lines.replace("graph_item_replace", graph_datas[0])
            data_lines = data_lines.replace("graph_datas_replace", graph_datas[1]) # 日付単位データ
            data_lines = data_lines.replace("graph_datas_2_replace", graph_datas[2]) # 日時単位データ(全計測点含む)
            data_lines = data_lines.replace("map_paint_color_replace", graph_datas[3])
            data_lines = data_lines.replace("legend_replace", graph_datas[4])

            if len(graph_datas[5]) >= 2:
                # circle_rangeを決める(３段階は固定)
                # max 250000, min 100000 ⇒ 差異は約 150000 で、３段階のため、ステップは約45000
                # ⇒ 25, 115000,  35, 160000,  45, 205000, 50
                try:
                    _max = int(graph_datas[5][0])
                    _min = int(graph_datas[5][1])
                    _diff = ((_max - _min)/8) * 0.9  # 3で割るとsetp1がmin自身になってしまうため

                    step_8 = _max - _diff
                    step_7 = _max - (_diff * 2)
                    step_6 = _max - (_diff * 3)
                    step_5 = _max - (_diff * 4)
                    step_4 = _max - (_diff * 5)
                    step_3 = _max - (_diff * 6)
                    step_2 = _max - (_diff * 7)
                    step_1 = _max - (_diff * 8)

                    circle_range = "20," + str(step_1) + ",  25," + str(step_2) + ",  30, " + str(step_3) + ", 35, " + str(step_4) + ", 40," + str(step_5) + ",  45," + str(step_6) + ",  50, " + str(step_7) + ", 55, " + str(step_8) + ", 60"
                    #circle_range = "25," + str(step_1) + ",  35," + str(step_2) + ",  45, " + str(step_3) + ", 55"
                    if _max == _min :
                        circle_range = "25, 115000,  35, 160000,  45, 205000, 50"
                    data_lines = data_lines.replace("circle_range_replace", circle_range)
                except:
                    circle_range = "25, 115000,  35, 160000,  45, 205000, 50"
                    data_lines = data_lines.replace("circle_range_replace", circle_range)                    

        if legend_flg :
            ranges = layer.renderer().ranges()
            if len(ranges) == 9 :
                for i in range(9) :
                    data_lines = data_lines.replace("legend_"+str(i+1)+"_replace", ranges[i].label())

        if self.add_poi :
            f = open(os.path.dirname(__file__) + '/temp/poi.geojson', 'r')
            str_geojson_poi = f.read()
            f.close()
            data_lines = data_lines.replace("poi_replace", str_geojson_poi)
        else :
            data_lines = data_lines.replace("poi_replace", "{}")
        
        #抽出条件
        data_lines = data_lines.replace("filter_col1_name_replace", self.filter.get('option1',['option1',''])[0])
        data_lines = data_lines.replace("filter_col2_name_replace", self.filter.get('option2',['option2',''])[0])
        data_lines = data_lines.replace("filter_col3_name_replace", self.filter.get('option3',['option3',''])[0])
        data_lines = data_lines.replace("filter_col4_name_replace", self.filter.get('option4',['option4',''])[0])
        data_lines = data_lines.replace("filter_col5_name_replace", self.filter.get('option5',['option5',''])[0])
        data_lines = data_lines.replace("filter_col6_name_replace", self.filter.get('option6',['option6',''])[0])
        data_lines = data_lines.replace("filter_col7_name_replace", self.filter.get('option7',['option7',''])[0])
        data_lines = data_lines.replace("filter_col8_name_replace", self.filter.get('option8',['option8',''])[0])
        data_lines = data_lines.replace("filter_col9_name_replace", self.filter.get('option9',['option9',''])[0])
        data_lines = data_lines.replace("filter_col10_name_replace", self.filter.get('option10',['option10',''])[0])
        data_lines = data_lines.replace("filter_col1_value_replace", self.filter.get('option1',['option1',''])[1])
        data_lines = data_lines.replace("filter_col2_value_replace", self.filter.get('option2',['option2',''])[1])
        data_lines = data_lines.replace("filter_col3_value_replace", self.filter.get('option3',['option3',''])[1])
        data_lines = data_lines.replace("filter_col4_value_replace", self.filter.get('option4',['option4',''])[1])
        data_lines = data_lines.replace("filter_col5_value_replace", self.filter.get('option5',['option5',''])[1])
        data_lines = data_lines.replace("filter_col6_value_replace", self.filter.get('option6',['option6',''])[1])
        data_lines = data_lines.replace("filter_col7_value_replace", self.filter.get('option7',['option7',''])[1])
        data_lines = data_lines.replace("filter_col8_value_replace", self.filter.get('option8',['option8',''])[1])
        data_lines = data_lines.replace("filter_col9_value_replace", self.filter.get('option9',['option9',''])[1])
        data_lines = data_lines.replace("filter_col10_value_replace", self.filter.get('option10',['option10',''])[1])

        with open(file_name+'.html', mode="w", encoding="utf-8") as f:
            f.write(data_lines)
            

    def fill_color_attribute_graduatedsymbol_renderer(self, layer, attribute):
        """ Set the color with a graduated symbol renderer """
        if layer.dataProvider().fields().indexFromName(attribute) == -1 :
            layer.dataProvider().addAttributes([QgsField(attribute,QVariant.String)])
            layer.updateFields()
        renderer = layer.renderer()
        provider = layer.dataProvider()
        attribute_index = layer.dataProvider().fields().indexFromName(attribute)
        attrvalindex = provider.fieldNameIndex(renderer.classAttribute())
        feat = QgsFeature()

        for feat in layer.getFeatures():

            fid = feat.id()
            attribute_map = feat.attributes()
            value = float(attribute_map[attrvalindex])

            colorval = "#FF00FF"

            for r in renderer.ranges():
                if value >= r.lowerValue() \
                   and value <= r.upperValue() \
                   and colorval == "#FF00FF":
                        colorval = r.symbol().color().name()

            newattrs = {attribute_index: colorval}
            provider.changeAttributeValues({fid: newattrs})

    def create_mesh(self,mesh_list,index):
        if len(QgsProject.instance().mapLayersByName('sptial')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('sptial')[0].id())

        meshlayer = QgsVectorLayer('Polygon?crs=epsg:4326', 'sptial' , 'memory')
        meshlayer.setProviderEncoding('UTF-8')
        meshlayer.dataProvider().setEncoding('UTF-8')   
        meshlayerprov = meshlayer.dataProvider()   
        meshlayerprov.addAttributes([QgsField("meshcode", QVariant.String)])
        meshlayer.updateFields() 
        
        for grid_code in mesh_list:
            if index >= 5 :
                result = worldmesh.meshcode_to_latlong_grid('20' + grid_code,True)
            else :    
                result = worldmesh.meshcode_to_latlong_grid('20' + grid_code)
            
            pt1 = QgsPointXY(result["long0"],result["lat0"])
            pt2 = QgsPointXY(result["long1"],result["lat1"])
            
            feat = QgsFeature()
            feat.setGeometry(QgsGeometry.fromRect(QgsRectangle(pt1,pt2)))
            feat.setAttributes([grid_code])
            meshlayerprov.addFeatures([feat])
    
            meshlayer.updateExtents()

        QgsProject.instance().addMapLayers([meshlayer])


    def datafilter(self) :
        ########################################
        # 期間内データ取得

        # 地図用データ（計測点で集約）
        self.point_geo_features = {}
        # グラフデータ
        _temp_data_1 = {} # 日付(date)をキーとしたJSON
        _temp_data_2 = {} # 日時(date-time)をキーとしたJSON
        for row in self.file_002_data_list:
            # 期間
            if row[0] >= self.date_002_from and row[0] <= self.date_002_to:
                # 地図用データ
                if (row[1] in self.point_geo_features) == False:
                    self.point_geo_features[row[1]] = float(row[2])
                else:
                    self.point_geo_features[row[1]] += float(row[2])

                str_date_1 = row[0].strftime('%Y/%m/%d')
                str_date_2 = row[0].strftime('%Y/%m/%d %H:%M')

                # グラフデータ
                # 日付・idで集約
                if (str_date_1 in _temp_data_1) == False:
                    _temp_data_1[str_date_1] = {}
                    _temp_data_1[str_date_1]['date'] = str_date_1 # 日付も格納

                _id = row[1]
                if (_id in _temp_data_1[str_date_1]) == False:
                    _temp_data_1[str_date_1][_id] = float(row[2])
                else:
                    _temp_data_1[str_date_1][_id] += float(row[2])

                # 集約なし
                if (str_date_2 in _temp_data_2) == False:
                    _temp_data_2[str_date_2] = []
                _temp_data_2[str_date_2].append({'id':row[1],'value':row[2]})

        # グラフデータを整形する
        # ex: {date: "2020-02-17 10:00:00", '111': 100, '112': 100, '113': 80}
        self.file_002_term_data_1 = "" # JSONの配列の文字列
        self.file_002_term_data_2 = "" # JSONの配列の文字列
        for _date in _temp_data_1:
            temp_json = _temp_data_1[_date]
            self.file_002_term_data_1 += (json.dumps(temp_json)) + ","

        for _date in _temp_data_2:
            temp_json = {'date':_date}
            # 計測点ごとの数値
            for item in _temp_data_2[_date]:
                temp_json[item['id']] = item['value']

            self.file_002_term_data_2 += (json.dumps(temp_json)) + ","

    def do_crosstab(self) :
        # エリア座標値取得
        pointList = {}
        cols = []
        file_encoding = encodingCheck(self.file_003_sensor_path)
          
        with open(self.file_003_sensor_path, encoding=file_encoding, newline='') as f:
            csvreader = csv.reader(f)
            header = next(csvreader)
            for row in csvreader:
                pointList[str(row[0])] = [row[1],row[2]]
                cols.append(str(row[0]))
        html_cross_combo = '<select id="cross_combo" onchange="selectboxChange();">'
        for k, v in pointList.items():
            html_cross_combo += '<option value="'+ v[1] + ',' + v[0]+ '">' + k + '</option>'
        html_cross_combo += '</select>'

        layer1 = QgsProject.instance().mapLayersByName('csv')[0]
        QgsVectorFileWriter.writeAsVectorFormat(
            layer1,
            os.path.dirname(__file__) + '/temp/result_003.csv',
            'UTF-8',
            QgsCoordinateReferenceSystem("EPSG:4326"),
            'CSV'
        )
        df = pd.read_csv(os.path.dirname(__file__) + '/temp/result_003.csv',dtype=str)
        df['value'] = df['value'].astype('float')
        cross1 = pd.crosstab(df['origin'], df['destination'],df['value'],aggfunc=np.sum)
        #cols = list(cross1.columns)

        csv_cross1 = [['origin','destination','value','lat','lon']]
        html_cross1 = '<table  class="od-table"><tbody><tr><th class="od_title">O/D</th>'
        for n in cols:
            html_cross1 += '<th class="destination">' + str(n) + '</th>'
        html_cross1 += '</tr>'
        for n in cols:
            cnt = 0
            html_cross1 += '<tr>'
            for m in cols:
                try:
                    value = cross1[m][n]
                    value = int(value)
                except:
                    value = 0

                if cnt == 0 :
                    html_cross1 += '<th class="origin">' + str(n) + '</th>'
                    html_cross1 += '<td>' + "{:,}".format(int(value)) + '</td>'
                else :
                    html_cross1 += '<td>' + "{:,}".format(int(value)) + '</td>'
                csv_cross1.append([n,m,value,pointList[str(m)][0],pointList[str(m)][1]])
                cnt = cnt + 1
            html_cross1 += '</tr>'

        html_cross1 += '</tbody></table>'

        with open(os.path.dirname(__file__) + '/temp/result_003_csv_001.csv', 'w', newline='') as file:
            writer = csv.writer(file, quoting=csv.QUOTE_ALL,delimiter=',')
            writer.writerows(csv_cross1)

        cross2 = pd.crosstab(df['destination'], df['origin'],df['value'],aggfunc=np.sum)

        csv_cross2 = [['destination','origin','value','lat','lon']]
        html_cross2 = '<table  class="od-table"><tbody><tr><th class="od_title">D/O</th>'
        for n in cols:
            html_cross2 += '<th class="origin">' + str(n) + '</th>'
        html_cross2 += '</tr>'
        for n in cols:
            cnt = 0
            html_cross2 += '<tr>'
            for m in cols:
                try:
                    value = cross2[m][n]
                    value = int(value)
                except:
                    value = 0
                if cnt == 0 :
                    html_cross2 += '<th class="destination">' + str(n) + '</th>'
                    html_cross2 += '<td>' + "{:,}".format(int(value)) + '</td>'
                else :
                    html_cross2 += '<td>' + "{:,}".format(int(value)) + '</td>'
                csv_cross2.append([n,m,value,pointList[str(m)][0],pointList[str(m)][1]])
                cnt = cnt + 1
            html_cross2 += '</tr>'
            
        html_cross2 += '</tbody></table>'

        with open(os.path.dirname(__file__) + '/temp/result_003_csv_002.csv', 'w', newline='') as file:
            writer = csv.writer(file, quoting=csv.QUOTE_ALL,delimiter=',')
            writer.writerows(csv_cross2)

        dff = df[df['origin'] != df['destination']]

        if len(dff) == 0:
            return "","","","",""

        cross3 = pd.crosstab(dff['origin'], dff['destination'],dff['value'],aggfunc=np.sum, normalize='index')
        
        csv_cross3 = [['origin','destination','value','lat','lon']]
        html_cross3 = '<table  class="od-table"><tbody><tr><th class="od_title">O/D</th>'
        for n in cols:
            html_cross3 += '<th class="destination">' + str(n) + '</th>'
        html_cross3 += '</tr>'
        for n in cols:
            cnt = 0
            html_cross3 += '<tr>'
            for m in cols:
                try:
                    value = cross3[m][n]
                    value = float(value)
                except:
                    value = 0
                if cnt == 0 :
                    html_cross3 += '<th class="origin">' + str(n) + '</th>'
 
                if m == n :
                    html_cross3 += '<td class="emp"></td>'
                else:
                    html_cross3 += '<td>' + '{:.2f}'.format(value * 100) + '%</td>'
 
                csv_cross3.append([n,m,value,pointList[str(m)][0],pointList[str(m)][1]])
                cnt = cnt + 1
            html_cross3 += '</tr>'

        html_cross3 += '</tbody></table>'

        with open(os.path.dirname(__file__) + '/temp/result_003_csv_003.csv', 'w', newline='') as file:
            writer = csv.writer(file, quoting=csv.QUOTE_ALL,delimiter=',')
            writer.writerows(csv_cross3)

        uri = 'file:///'+os.path.dirname(__file__) + '/temp/result_003_csv_003.csv'+'?delimiter={}&crs=epsg:4326&xField={}&yField={}'.format(',', 'lon', 'lat')

        #読み込み
        if len(QgsProject.instance().mapLayersByName('origin')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('origin')[0].id())

        layer = QgsVectorLayer(uri, 'origin', 'delimitedtext') 

        #レイヤに追加
        QgsProject.instance().addMapLayer(layer)

        QgsVectorFileWriter.writeAsVectorFormat(
            layer,
            os.path.dirname(__file__) + '/temp/origin.geojson',
            'UTF-8',
            QgsCoordinateReferenceSystem("EPSG:4326"),
            'GeoJSON'
        )

        cross4 = pd.crosstab(dff['destination'], dff['origin'],dff['value'],aggfunc=np.sum, normalize='index')
        
        csv_cross4 = [['destination','origin','value','lat','lon']]
        html_cross4 = '<table  class="od-table"><tbody><tr><th class="od_title">D/O</th>'
        for n in cols:
            html_cross4 += '<th class="origin">' + str(n) + '</th>'
        html_cross4 += '</tr>'
        for n in cols:
            cnt = 0
            html_cross4 += '<tr>'
            for m in cols:
                if cnt == 0 :
                    html_cross4 += '<th class="destination">' + str(n) + '</th>'
                try:
                    value = cross4[m][n]
                    value = float(value)
                except:
                    value = 0
                if m == n :
                    html_cross4 += '<td class="emp"></td>'
                else:
                    html_cross4 += '<td>' + '{:.2f}'.format(value * 100) + '%</td>'

                csv_cross4.append([n,m,value,pointList[str(m)][0],pointList[str(m)][1]])
                cnt = cnt + 1
            html_cross4 += '</tr>'

        html_cross4 += '</tbody></table>'

        with open(os.path.dirname(__file__) + '/temp/result_003_csv_004.csv', 'w', newline='') as file:
            writer = csv.writer(file, quoting=csv.QUOTE_ALL,delimiter=',')
            writer.writerows(csv_cross4)

        uri = 'file:///'+os.path.dirname(__file__) + '/temp/result_003_csv_004.csv'+'?delimiter={}&crs=epsg:4326&xField={}&yField={}'.format(',', 'lon', 'lat')

        #読み込み
        if len(QgsProject.instance().mapLayersByName('destination')) >= 1 :
            QgsProject.instance().removeMapLayer(QgsProject.instance().mapLayersByName('destination')[0].id())

        layer = QgsVectorLayer(uri, 'destination', 'delimitedtext') 

        #レイヤに追加
        QgsProject.instance().addMapLayer(layer)


        QgsVectorFileWriter.writeAsVectorFormat(
            layer,
            os.path.dirname(__file__) + '/temp/destination.geojson',
            'UTF-8',
            QgsCoordinateReferenceSystem("EPSG:4326"),
            'GeoJSON'
        )

        return html_cross_combo,html_cross1,html_cross2,html_cross3,html_cross4


    def do_crosstab_time(self) :
        cols = []
        file_encoding = encodingCheck(self.file_003_sensor_path)

        with open(self.file_003_sensor_path, encoding=file_encoding, newline='') as f:
            csvreader = csv.reader(f)
            header = next(csvreader)
            for row in csvreader:
                cols.append(str(row[0]))

        df = pd.read_csv(os.path.dirname(__file__) + '/temp/result_003.csv',dtype=str)

        df['value'] = df['value'].astype('float')
        df['time_o'] = pd.to_datetime(df['time_o'])
        df['time_d'] = pd.to_datetime(df['time_d'])

        df['diff'] = df['time_d'] - df['time_o']
        df['diff_ts'] = df['diff'].dt.total_seconds()/60.0
        diff = int(df.iloc[0]['diff_ts'])


        df0 = df.copy()[df['origin']==df['destination']]
        for i in range(diff, 390, diff):
            df1 = df0.copy()[['id', 'time_o', 'time_d', 'origin', 'destination']]
            df2 = df1.copy()[['id', 'time_o', 'destination']]
            df2[f'timezone_{i+diff}'] = df2['time_o'] + timedelta(minutes=i)
            df2.drop(columns=['time_o'], inplace=True)
            df3 = pd.merge(df1, df2, left_on=['id', 'time_o', 'destination'], right_on=['id', f'timezone_{i+diff}', 'destination'], how='left')

            df3[f'stay{i+diff}m'] = df3['destination']
            df3 = df3[~df3['destination'].isnull()][['id', 'destination', f'timezone_{i+diff}', f'stay{i+diff}m']]
            df3.reset_index(drop=True, inplace=True)

            if i == diff:
                df0 = pd.merge(df0, df3, left_on=['id', 'time_o', 'destination'], right_on=['id', f'timezone_{i+diff}', 'destination'], how='left')
            else:
                df3.drop(columns=['destination'], inplace=True)
                df0 = pd.merge(df0, df3, left_on=['id', f'timezone_{i}', f'stay{i}m'], right_on=['id', f'timezone_{i+diff}', f'stay{i+diff}m'], how='left')

        for i in range(2*diff, 390+diff, diff):
            df0.loc[~df0[f'stay{i}m'].isnull(), 'con_stay_time'] = i
            df0.drop(columns=[f'timezone_{i}', f'stay{i}m'], inplace=True)

        df = pd.merge(df, df0[['id', 'time_o', 'con_stay_time']], on=(['id', 'time_o']), how='left')

        
        df['temp'] = df.groupby('id', as_index=False)['con_stay_time'].shift(-1)
        df.loc[df['temp'].notnull(), 'con_stay_time'] = np.nan
        df.drop(columns='temp', inplace=True)


        df.loc[(df['con_stay_time'] > 0) & (df['con_stay_time'] <= 60), 'con_stay_time_sum'] = '0.5-1.0'
        df.loc[(df['con_stay_time'] > 60) & (df['con_stay_time'] <= 90), 'con_stay_time_sum'] = '1.0-1.5'
        df.loc[(df['con_stay_time'] > 90) & (df['con_stay_time'] <= 120), 'con_stay_time_sum'] = '1.5-2.0'
        df.loc[(df['con_stay_time'] > 120) & (df['con_stay_time'] <= 180), 'con_stay_time_sum'] = '2.0-3.0'
        df.loc[(df['con_stay_time'] > 180) & (df['con_stay_time'] <= 360), 'con_stay_time_sum'] = '3.0-6.0'
        df.loc[(df['con_stay_time'] > 360), 'con_stay_time_sum'] = '6.0-'

        tab = pd.crosstab(df['destination'], df['con_stay_time_sum'],df['value'],aggfunc=np.sum)

        html_cross1 = '<table  class="time-table"><tbody><tr><th></th>'
        html_cross1 += '<th>30～60分</th>'
        html_cross1 += '<th>1～1.5時間</th>'
        html_cross1 += '<th>1.5～2時間</th>'
        html_cross1 += '<th>2～3時間</th>'
        html_cross1 += '<th>3～6時間</th>'
        html_cross1 += '<th>6時間～</th>'
        html_cross1 += '</tr>'

        cols2 = ['dm','0.5-1.0','1.0-1.5','1.5-2.0','2.0-3.0','3.0-6.0','6.0-']

        for col in cols:
            #data.to_csv("c:/work/test.csv")
            html_cross1 += '<tr>'
            cnt = 0
            for col2 in cols2:
                #QMessageBox.warning(None, "",tab[col2][col])
                try:
                    value = tab[col2][col]
                except:
                    value = 0

                if cnt == 0 :
                    html_cross1 += '<th>' + col + '</th>'
                else :
                    try:
                        value_i = int(value)
                    except:
                        value_i = 0
                    
                    html_cross1 += '<td>' + "{:,}".format(value_i) + '</td>'
                cnt = cnt + 1
            html_cross1 += '</tr>'

        html_cross1 += '</tbody></table>'

        tab = pd.crosstab(df['destination'], df['con_stay_time_sum'],df['value'],aggfunc=np.sum,normalize='index')

        html_cross2 = '<table  class="time-table"><tbody><tr><th></th>'
        html_cross2 += '<th>30～60分</th>'
        html_cross2 += '<th>1～1.5時間</th>'
        html_cross2 += '<th>1.5～2時間</th>'
        html_cross2 += '<th>2～3時間</th>'
        html_cross2 += '<th>3～6時間</th>'
        html_cross2 += '<th>6時間～</th>'
        html_cross2 += '</tr>'

        for col in cols:
            cnt = 0
            html_cross2 += '<tr>'
            for col2 in cols2:
                
                try:
                    value = tab[col2][col]
                except:
                    value = 0

                if cnt == 0 :
                    html_cross2 += '<th>' + col + '</th>'
                else :
                    try:
                        value_i = float(value)
                    except:
                        value_i = 0.0
                    html_cross2 += '<td>' + '{:.2f}'.format(value_i * 100) + '%</td>'
                cnt = cnt + 1
            html_cross2 += '</tr>'

        html_cross2 += '</tbody></table>'

        return html_cross1,html_cross2

    def replaceData_003(self,select_value) :
        layer = QgsProject.instance().mapLayersByName('result')[0]
        ext = layer.extent()
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        coords = "%f,%f" %((xmin+xmax)/2.0, (ymin+ymax)/2.0) 
        bound1 = "%f,%f" %(xmin,ymin) 
        bound2 = "%f,%f" %(xmax,ymax)

        self.iface.mapCanvas().setExtent(ext)

        zoom = getZoomFromScale(self.iface.mapCanvas().scale()) - 2

        html_cross_combo,html_cross1,html_cross2,html_cross3,html_cross4 = self.do_crosstab()
        html_cross5,html_cross6 = self.do_crosstab_time()
        if html_cross_combo == "" :
            return False

        f = open(os.path.dirname(__file__) + '/temp/result_003.geojson', 'r')
        str_geojson = f.read()
        f.close()

        # featuresにidを付与する
        temp_geojson = json.loads(str_geojson)
        features = temp_geojson['features']
        # print("features before", temp_geojson['features'][0])
        i_id = 1
        for feat in features:
            # 一意性を確保するため順番に付与する
            feat['id']  = i_id
            i_id += 1
        str_geojson = json.dumps(temp_geojson)


        f = open(os.path.dirname(__file__) + '/temp/origin.geojson', 'r')
        str_geojson2 = f.read()
        f.close()

        f = open(os.path.dirname(__file__) + '/temp/destination.geojson', 'r')
        str_geojson3 = f.read()
        f.close()

        file_name = os.path.dirname(__file__) + '/html/003.html'
        with open(file_name, encoding="utf-8") as f:
            data_lines = f.read()

        data_lines = data_lines.replace("data_replace", str_geojson)
        data_lines = data_lines.replace("data2_replace", str_geojson2)
        data_lines = data_lines.replace("data3_replace", str_geojson3)

        #data_lines = data_lines.replace("combo_replace", html_cross_combo)
        data_lines = data_lines.replace("table1_replace", html_cross1)
        data_lines = data_lines.replace("table2_replace", html_cross2)
        data_lines = data_lines.replace("table3_replace", html_cross3)
        data_lines = data_lines.replace("table4_replace", html_cross4)

        data_lines = data_lines.replace("table5_replace", html_cross5)
        data_lines = data_lines.replace("table6_replace", html_cross6)

        data_lines = data_lines.replace("center_replace", coords)
        data_lines = data_lines.replace("zoom_replace", str(zoom))
        data_lines = data_lines.replace("bound_replace_1", bound1)
        data_lines = data_lines.replace("bound_replace_2", bound2)
        #抽出条件
        data_lines = data_lines.replace("filter_col1_name_replace", self.filter.get('option1',['option1',''])[0])
        data_lines = data_lines.replace("filter_col1_value_replace", self.filter.get('option1',['option1',''])[1])
        data_lines = data_lines.replace("filter_col2_name_replace", self.filter.get('option2',['option2',''])[0])
        data_lines = data_lines.replace("filter_col2_value_replace", self.filter.get('option2',['option2',''])[1])
        data_lines = data_lines.replace("filter_col3_name_replace", self.filter.get('option3',['option3',''])[0])
        data_lines = data_lines.replace("filter_col3_value_replace", self.filter.get('option3',['option3',''])[1])
        data_lines = data_lines.replace("filter_col4_name_replace", self.filter.get('option4',['option4',''])[0])
        data_lines = data_lines.replace("filter_col4_value_replace", self.filter.get('option4',['option4',''])[1])
        data_lines = data_lines.replace("filter_col5_name_replace", self.filter.get('option5',['option5',''])[0])
        data_lines = data_lines.replace("filter_col5_value_replace", self.filter.get('option5',['option5',''])[1])

        #初期値
        if len(select_value) > 3 :
            data_lines = data_lines.replace("option1_replace", select_value[3])
        else :
            data_lines = data_lines.replace("option1_replace", "")
        if len(select_value) > 4 :
            data_lines = data_lines.replace("option2_replace", select_value[4])
        else :
            data_lines = data_lines.replace("option2_replace", "")
        if len(select_value) > 5 :
            data_lines = data_lines.replace("option3_replace", select_value[5])
        else :
            data_lines = data_lines.replace("option3_replace", "")
        if len(select_value) > 6 :
            data_lines = data_lines.replace("option4_replace", select_value[6])
        else :
            data_lines = data_lines.replace("option4_replace", "")
        if len(select_value) > 7 :
            data_lines = data_lines.replace("option5_replace", select_value[7])
        else :
            data_lines = data_lines.replace("option5_replace", "")

        data_lines = data_lines.replace("table_area_replace", select_value[0])


        data_lines = data_lines.replace("select_areaname_replace", '"' + select_value[0] + '"')
        data_lines = data_lines.replace("select_startgeom_replace", select_value[2] + ',' +select_value[1]  )


        with open(file_name+'.html', mode="w", encoding="utf-8") as f:
            f.write(data_lines)

        return True


    def replaceData_004(self):
        test = QgsProject.instance().mapLayersByName('csv')[0]
        idx_user_id = test.dataProvider().fields().indexFromName('id')
        idx_lat = test.dataProvider().fields().indexFromName('lat')
        idx_lon = test.dataProvider().fields().indexFromName('lon')
        idx_time = test.dataProvider().fields().indexFromName('timestamp')

        user_id = processing.run("qgis:listuniquevalues", {'INPUT':test,'FIELDS':['id'],'OUTPUT':'TEMPORARY_OUTPUT'})
        user_id_list = []
        i = 0
        replace_min = 99999999999999999
        replace_max = 0

        for item in user_id["OUTPUT"].getFeatures():
            request = QgsFeatureRequest(QgsExpression("\"id\" = '" + item.attributes()[0] + "'"))
            clause = QgsFeatureRequest.OrderByClause('timestamp', ascending=True)
            orderby = QgsFeatureRequest.OrderBy([clause])
            request.setOrderBy(orderby)
            selection = test.getFeatures(request)
            
            user = {}
            path_all = []
            time_all = []
            j = 0
            for feature in selection:
                user = {}
                user["vendor"] = i
                if j==0 :
                    lat_1 = feature.attributes()[idx_lat]
                    lon_1 = feature.attributes()[idx_lon]
                    path_1 = [lon_1,lat_1]
                    time_1 = float(str(feature.attributes()[idx_time].toMSecsSinceEpoch()))
                else :
                    lat_2 = feature.attributes()[idx_lat]
                    lon_2 = feature.attributes()[idx_lon]
                    path_2 = [lon_2,lat_2]
                    time_2 = float(str(feature.attributes()[idx_time].toMSecsSinceEpoch()))
                    user["path"] = [path_1,path_2]
                    user["timestamps"] = [time_1,time_2]

                    if time_2 > replace_max :
                        replace_max = time_2

                    if time_2 < replace_min :
                        replace_min = time_2

                    lat_1 = feature.attributes()[idx_lat]
                    lon_1 = feature.attributes()[idx_lon]
                    path_1 = [lon_1,lat_1]
                    time_1 = float(str(feature.attributes()[idx_time].toMSecsSinceEpoch()))
                    
                    user_id_list.append(user)
                j = j+1
        
            i = i+1


        
        replace_data = json.dumps(user_id_list)

        file_name = os.path.dirname(__file__) + '/html/003-2.html'
        with open(file_name, encoding="utf-8") as f:
            data_lines = f.read()

        data_lines = data_lines.replace("replace_min", str(replace_min))
        data_lines = data_lines.replace("replace_max", str(replace_max))

        data_lines = data_lines.replace("replace_data", replace_data)

        with open(file_name+'.html', mode="w", encoding="utf-8") as f:
            f.write(data_lines)

        return True

def isonlynum(s):
    return True if re.fullmatch('[0-9]+', s) else False

def getZoomFromScale(scale):
    z = None
    if scale < 1250:
        z=18
    elif scale < 2500:
        z=17
    elif scale < 5000:
        z=16
    elif scale < 10000:
        z=15
    elif scale < 20000:
        z=14
    elif scale < 40000:
        z=13
    elif scale < 100000:
        z=12
    elif scale < 200000:
        z=11
    elif scale < 400000:
        z=10
    elif scale < 1000000:
        z=9
    elif scale < 2000000:
        z=8
    elif scale < 4000000:
        z=7
    elif scale < 8000000:
        z=6
    else:
        z=5

    # １段階zoom_out
    return z-0.5

def encodingCheck(file_path) :
    with open(file_path, mode='rb') as f:
        b = f.read()
        encoding_info = detect(b)

    file_encoding = encoding_info['encoding']
    if file_encoding == "utf-8":
        file_encoding = "utf-8"
    elif file_encoding == "SHIFT_JIS":
        file_encoding = "cp932"
    elif file_encoding == "Windows-1252":
        file_encoding = "cp932"
    elif file_encoding == "ascii":
        file_encoding = "cp932"
    elif file_encoding == "UTF-8-SIG":
        file_encoding = "utf-8-sig"
    else :
        file_encoding = "error:" + file_encoding

    return file_encoding
    
